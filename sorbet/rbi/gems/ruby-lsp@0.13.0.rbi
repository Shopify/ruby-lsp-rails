# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ruby-lsp` gem.
# Please instead update this file by running `bin/tapioca gem ruby-lsp`.

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#4
module RubyIndexer
  class << self
    # source://ruby-lsp/lib/ruby_indexer/ruby_indexer.rb#21
    sig { returns(::RubyIndexer::Configuration) }
    def configuration; end
  end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#5
class RubyIndexer::Collector
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#11
  sig { params(index: ::RubyIndexer::Index, parse_result: ::Prism::ParseResult, file_path: ::String).void }
  def initialize(index, parse_result, file_path); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#28
  sig { params(node: ::Prism::Node).void }
  def collect(node); end

  private

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#267
  sig { params(node: ::Prism::ClassNode).void }
  def add_class_entry(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#227
  sig do
    params(
      node: T.any(::Prism::ConstantAndWriteNode, ::Prism::ConstantOperatorWriteNode, ::Prism::ConstantOrWriteNode, ::Prism::ConstantPathAndWriteNode, ::Prism::ConstantPathOperatorWriteNode, ::Prism::ConstantPathOrWriteNode, ::Prism::ConstantPathTargetNode, ::Prism::ConstantPathWriteNode, ::Prism::ConstantTargetNode, ::Prism::ConstantWriteNode),
      name: ::String,
      value: T.nilable(::Prism::Node)
    ).void
  end
  def add_constant(node, name, value = T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#252
  sig { params(node: ::Prism::ModuleNode).void }
  def add_module_entry(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#296
  sig { params(node: ::Prism::Node).returns(T::Array[::String]) }
  def collect_comments(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#318
  sig { params(name: ::String).returns(::String) }
  def fully_qualify_name(name); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#327
  sig { params(node: ::Prism::CallNode, reader: T::Boolean, writer: T::Boolean).void }
  def handle_attribute(node, reader:, writer:); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#143
  sig { params(node: ::Prism::CallNode).void }
  def handle_call_node(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#127
  sig { params(node: ::Prism::ConstantPathAndWriteNode).void }
  def handle_constant_path_and_write_node(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#117
  sig { params(node: ::Prism::ConstantPathOperatorWriteNode).void }
  def handle_constant_path_operator_write_node(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#107
  sig { params(node: ::Prism::ConstantPathOrWriteNode).void }
  def handle_constant_path_or_write_node(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#97
  sig { params(node: ::Prism::ConstantPathWriteNode).void }
  def handle_constant_path_write_node(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#137
  sig { params(node: ::Prism::ConstantWriteNode).void }
  def handle_constant_write_node(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#159
  sig { params(node: ::Prism::DefNode).void }
  def handle_def_node(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#77
  sig { params(node: ::Prism::MultiWriteNode).void }
  def handle_multi_write_node(node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#185
  sig { params(node: ::Prism::CallNode).void }
  def handle_private_constant(node); end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/collector.rb#8
RubyIndexer::Collector::LEAVE_EVENT = T.let(T.unsafe(nil), Object)

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#5
class RubyIndexer::Configuration
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#20
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#61
  sig { returns(T::Array[::RubyIndexer::IndexablePath]) }
  def indexables; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#47
  sig { void }
  def load_config; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#157
  sig { returns(::Regexp) }
  def magic_comment_regex; end

  private

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#179
  sig { params(config: T::Hash[::String, T.untyped]).void }
  def apply_config(config); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#188
  sig { returns(T::Array[::String]) }
  def initial_excluded_gems; end

  # @raise [ArgumentError]
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#164
  sig { params(config: T::Hash[::String, T.untyped]).void }
  def validate_config!(config); end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/configuration.rb#8
RubyIndexer::Configuration::CONFIGURATION_SCHEMA = T.let(T.unsafe(nil), Hash)

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#5
class RubyIndexer::Entry
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#24
  sig { params(name: ::String, file_path: ::String, location: ::Prism::Location, comments: T::Array[::String]).void }
  def initialize(name, file_path, location, comments); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#18
  sig { returns(T::Array[::String]) }
  def comments; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#33
  sig { returns(::String) }
  def file_name; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#12
  sig { returns(::String) }
  def file_path; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#15
  sig { returns(::Prism::Location) }
  def location; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#9
  sig { returns(::String) }
  def name; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#21
  sig { returns(::Symbol) }
  def visibility; end

  # @return [Symbol]
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#21
  def visibility=(_arg0); end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#136
class RubyIndexer::Entry::Accessor < ::RubyIndexer::Entry::Member
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#140
  sig { override.returns(T::Array[::RubyIndexer::Entry::Parameter]) }
  def parameters; end
end

# Alias represents a resolved alias, which points to an existing constant target
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#268
class RubyIndexer::Entry::Alias < ::RubyIndexer::Entry
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#275
  sig { params(target: ::String, unresolved_alias: ::RubyIndexer::Entry::UnresolvedAlias).void }
  def initialize(target, unresolved_alias); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#272
  sig { returns(::String) }
  def target; end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#52
class RubyIndexer::Entry::Class < ::RubyIndexer::Entry::Namespace
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#69
  sig do
    params(
      name: ::String,
      file_path: ::String,
      location: ::Prism::Location,
      comments: T::Array[::String],
      parent_class: T.nilable(::String)
    ).void
  end
  def initialize(name, file_path, location, comments, parent_class); end

  # The unresolved name of the parent class. This may return `nil`, which indicates the lack of an explicit parent
  # and therefore ::Object is the correct parent class
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#58
  sig { returns(T.nilable(::String)) }
  def parent_class; end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#75
class RubyIndexer::Entry::Constant < ::RubyIndexer::Entry; end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#227
class RubyIndexer::Entry::InstanceMethod < ::RubyIndexer::Entry::Method; end

# An required keyword method parameter, e.g. `def foo(a:)`
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#102
class RubyIndexer::Entry::KeywordParameter < ::RubyIndexer::Entry::Parameter; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#109
class RubyIndexer::Entry::Member < ::RubyIndexer::Entry
  abstract!

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#127
  sig do
    params(
      name: ::String,
      file_path: ::String,
      location: ::Prism::Location,
      comments: T::Array[::String],
      owner: T.nilable(::RubyIndexer::Entry::Namespace)
    ).void
  end
  def initialize(name, file_path, location, comments, owner); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#116
  sig { returns(T.nilable(::RubyIndexer::Entry::Namespace)) }
  def owner; end

  # @abstract
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#133
  sig { abstract.returns(T::Array[::RubyIndexer::Entry::Parameter]) }
  def parameters; end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#147
class RubyIndexer::Entry::Method < ::RubyIndexer::Entry::Member
  abstract!

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#166
  sig do
    params(
      name: ::String,
      file_path: ::String,
      location: ::Prism::Location,
      comments: T::Array[::String],
      parameters_node: T.nilable(::Prism::ParametersNode),
      owner: T.nilable(::RubyIndexer::Entry::Namespace)
    ).void
  end
  def initialize(name, file_path, location, comments, parameters_node, owner); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#154
  sig { override.returns(T::Array[::RubyIndexer::Entry::Parameter]) }
  def parameters; end

  private

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#175
  sig do
    params(
      parameters_node: T.nilable(::Prism::ParametersNode)
    ).returns(T::Array[::RubyIndexer::Entry::Parameter])
  end
  def list_params(parameters_node); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#210
  sig { params(node: ::Prism::Node).returns(T.nilable(::Symbol)) }
  def parameter_name(node); end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#49
class RubyIndexer::Entry::Module < ::RubyIndexer::Entry::Namespace; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#37
class RubyIndexer::Entry::Namespace < ::RubyIndexer::Entry
  abstract!

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#44
  sig { returns(::String) }
  def short_name; end
end

# An optional keyword method parameter, e.g. `def foo(a: 123)`
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#106
class RubyIndexer::Entry::OptionalKeywordParameter < ::RubyIndexer::Entry::Parameter; end

# An optional method parameter, e.g. `def foo(a = 123)`
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#98
class RubyIndexer::Entry::OptionalParameter < ::RubyIndexer::Entry::Parameter; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#78
class RubyIndexer::Entry::Parameter
  abstract!

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#88
  sig { params(name: ::Symbol).void }
  def initialize(name:); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#85
  sig { returns(::Symbol) }
  def name; end
end

# A required method parameter, e.g. `def foo(a)`
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#94
class RubyIndexer::Entry::RequiredParameter < ::RubyIndexer::Entry::Parameter; end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#224
class RubyIndexer::Entry::SingletonMethod < ::RubyIndexer::Entry::Method; end

# An UnresolvedAlias points to a constant alias with a right hand side that has not yet been resolved. For
# example, if we find
#
# ```ruby
#   CONST = Foo
# ```
# Before we have discovered `Foo`, there's no way to eagerly resolve this alias to the correct target constant.
# All aliases are inserted as UnresolvedAlias in the index first and then we lazily resolve them to the correct
# target in [rdoc-ref:Index#resolve]. If the right hand side contains a constant that doesn't exist, then it's not
# possible to resolve the alias and it will remain an UnresolvedAlias until the right hand side constant exists
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#240
class RubyIndexer::Entry::UnresolvedAlias < ::RubyIndexer::Entry
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#259
  sig do
    params(
      target: ::String,
      nesting: T::Array[::String],
      name: ::String,
      file_path: ::String,
      location: ::Prism::Location,
      comments: T::Array[::String]
    ).void
  end
  def initialize(target, nesting, name, file_path, location, comments); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#247
  sig { returns(T::Array[::String]) }
  def nesting; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/entry.rb#244
  sig { returns(::String) }
  def target; end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#5
class RubyIndexer::Index
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#14
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#65
  sig { params(entry: ::RubyIndexer::Entry).void }
  def <<(entry); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#74
  sig { params(fully_qualified_name: ::String).returns(T.nilable(T::Array[::RubyIndexer::Entry])) }
  def [](fully_qualified_name); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#37
  sig { params(indexable: ::RubyIndexer::IndexablePath).void }
  def delete(indexable); end

  # Follows aliases in a namespace. The algorithm keeps checking if the name is an alias and then recursively follows
  # it. The idea is that we test the name in parts starting from the complete name to the first namespace. For
  # `Foo::Bar::Baz`, we would test:
  # 1. Is `Foo::Bar::Baz` an alias? Get the target and recursively follow its target
  # 2. Is `Foo::Bar` an alias? Get the target and recursively follow its target
  # 3. Is `Foo` an alias? Get the target and recursively follow its target
  #
  # If we find an alias, then we want to follow its target. In the same example, if `Foo::Bar` is an alias to
  # `Something::Else`, then we first discover `Something::Else::Baz`. But `Something::Else::Baz` might contain other
  # aliases, so we have to invoke `follow_aliased_namespace` again to check until we only return a real name
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#209
  sig { params(name: ::String).returns(::String) }
  def follow_aliased_namespace(name); end

  # Fuzzy searches index entries based on Jaro-Winkler similarity. If no query is provided, all entries are returned
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#116
  sig { params(query: T.nilable(::String)).returns(T::Array[::RubyIndexer::Entry]) }
  def fuzzy_search(query); end

  # Index all files for the given indexable paths, which defaults to what is configured. A block can be used to track
  # and control indexing progress. That block is invoked with the current progress percentage and should return `true`
  # to continue indexing or `false` to stop indexing.
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#171
  sig do
    params(
      indexable_paths: T::Array[::RubyIndexer::IndexablePath],
      block: T.nilable(T.proc.params(progress: ::Integer).returns(T::Boolean))
    ).void
  end
  def index_all(indexable_paths: T.unsafe(nil), &block); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#186
  sig { params(indexable_path: ::RubyIndexer::IndexablePath, source: T.nilable(::String)).void }
  def index_single(indexable_path, source = T.unsafe(nil)); end

  # Searches entries in the index based on an exact prefix, intended for providing autocomplete. All possible matches
  # to the prefix are returned. The return is an array of arrays, where each entry is the array of entries for a given
  # name match. For example:
  # ## Example
  # ```ruby
  # # If the index has two entries for `Foo::Bar` and one for `Foo::Baz`, then:
  # index.prefix_search("Foo::B")
  # # Will return:
  # [
  #   [#<Entry::Class name="Foo::Bar">, #<Entry::Class name="Foo::Bar">],
  #   [#<Entry::Class name="Foo::Baz">],
  # ]
  # ```
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#97
  sig do
    params(
      query: ::String,
      nesting: T.nilable(T::Array[::String])
    ).returns(T::Array[T::Array[::RubyIndexer::Entry]])
  end
  def prefix_search(query, nesting = T.unsafe(nil)); end

  # Try to find the entry based on the nesting from the most specific to the least specific. For example, if we have
  # the nesting as ["Foo", "Bar"] and the name as "Baz", we will try to find it in this order:
  # 1. Foo::Bar::Baz
  # 2. Foo::Baz
  # 3. Baz
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#135
  sig { params(name: ::String, nesting: T::Array[::String]).returns(T.nilable(T::Array[::RubyIndexer::Entry])) }
  def resolve(name, nesting); end

  # Attempts to find a given method for a resolved fully qualified receiver name. Returns `nil` if the method does not
  # exist on that receiver
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#243
  sig { params(method_name: ::String, receiver_name: ::String).returns(T.nilable(::RubyIndexer::Entry::Method)) }
  def resolve_method(method_name, receiver_name); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#79
  sig { params(query: ::String).returns(T::Array[::RubyIndexer::IndexablePath]) }
  def search_require_paths(query); end

  private

  # Attempts to resolve an UnresolvedAlias into a resolved Alias. If the unresolved alias is pointing to a constant
  # that doesn't exist, then we return the same UnresolvedAlias
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#257
  sig do
    params(
      entry: ::RubyIndexer::Entry::UnresolvedAlias
    ).returns(T.any(::RubyIndexer::Entry::Alias, ::RubyIndexer::Entry::UnresolvedAlias))
  end
  def resolve_alias(entry); end
end

# The minimum Jaro-Winkler similarity score for an entry to be considered a match for a given fuzzy search query
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#11
RubyIndexer::Index::ENTRY_SIMILARITY_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/index.rb#8
class RubyIndexer::Index::UnresolvableAliasError < ::StandardError; end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#5
class RubyIndexer::IndexablePath
  # An IndexablePath is instantiated with a load_path_entry and a full_path. The load_path_entry is where the file can
  # be found in the $LOAD_PATH, which we use to determine the require_path. The load_path_entry may be `nil` if the
  # indexer is configured to go through files that do not belong in the $LOAD_PATH. For example,
  # `sorbet/tapioca/require.rb` ends up being a part of the paths to be indexed because it's a Ruby file inside the
  # project, but the `sorbet` folder is not a part of the $LOAD_PATH. That means that both its load_path_entry and
  # require_path will be `nil`, since it cannot be required by the project
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#21
  sig { params(load_path_entry: T.nilable(::String), full_path: ::String).void }
  def initialize(load_path_entry, full_path); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#12
  sig { returns(::String) }
  def full_path; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#9
  sig { returns(T.nilable(::String)) }
  def require_path; end
end

# A PrefixTree is a data structure that allows searching for partial strings fast. The tree is similar to a nested
# hash structure, where the keys are the characters of the inserted strings.
#
# ## Example
# ```ruby
# tree = PrefixTree[String].new
# # Insert entries using the same key and value
# tree.insert("bar", "bar")
# tree.insert("baz", "baz")
# # Internally, the structure is analogous to this, but using nodes:
# # {
# #   "b" => {
# #     "a" => {
# #       "r" => "bar",
# #       "z" => "baz"
# #     }
# #   }
# # }
# # When we search it, it finds all possible values based on partial (or complete matches):
# tree.search("") # => ["bar", "baz"]
# tree.search("b") # => ["bar", "baz"]
# tree.search("ba") # => ["bar", "baz"]
# tree.search("bar") # => ["bar"]
# ```
#
# A PrefixTree is useful for autocomplete, since we always want to find all alternatives while the developer hasn't
# finished typing yet. This PrefixTree implementation allows for string keys and any arbitrary value using the generic
# `Value` type.
#
# See https://en.wikipedia.org/wiki/Trie for more information
#
# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#35
class RubyIndexer::PrefixTree
  extend T::Generic

  Value = type_member

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#42
  sig { void }
  def initialize; end

  # Deletes the entry identified by `key` from the tree. Notice that a partial match will still delete all entries
  # that match it. For example, if the tree contains `foo` and we ask to delete `fo`, then `foo` will be deleted
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#77
  sig { params(key: ::String).void }
  def delete(key); end

  # Inserts a `value` using the given `key`
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#60
  sig { params(key: ::String, value: Value).void }
  def insert(key, value); end

  # Search the PrefixTree based on a given `prefix`. If `foo` is an entry in the tree, then searching for `fo` will
  # return it as a result. The result is always an array of the type of value attribute to the generic `Value` type.
  # Notice that if the `Value` is an array, this method will return an array of arrays, where each entry is the array
  # of values for a given match
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#51
  sig { params(prefix: ::String).returns(T::Array[Value]) }
  def search(prefix); end

  private

  # Find a node that matches the given `key`
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#97
  sig { params(key: ::String).returns(T.nilable(RubyIndexer::PrefixTree::Node[Value])) }
  def find_node(key); end
end

# source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#110
class RubyIndexer::PrefixTree::Node
  extend T::Generic

  Value = type_member

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#132
  sig { params(key: ::String, value: Value, parent: T.nilable(RubyIndexer::PrefixTree::Node[Value])).void }
  def initialize(key, value, parent = T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#117
  sig { returns(T::Hash[::String, RubyIndexer::PrefixTree::Node[Value]]) }
  def children; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#141
  sig { returns(T::Array[Value]) }
  def collect; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#120
  sig { returns(::String) }
  def key; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#126
  sig { returns(T::Boolean) }
  def leaf; end

  # @return [Boolean]
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#126
  def leaf=(_arg0); end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#129
  sig { returns(T.nilable(RubyIndexer::PrefixTree::Node[Value])) }
  def parent; end

  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#123
  sig { returns(Value) }
  def value; end

  # @return [Value]
  #
  # source://ruby-lsp/lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#123
  def value=(_arg0); end
end

# source://ruby-lsp/lib/ruby-lsp.rb#4
module RubyLsp; end

# To register an addon, inherit from this class and implement both `name` and `activate`
#
# # Example
#
# ```ruby
# module MyGem
#   class MyAddon < Addon
#     def activate
#       # Perform any relevant initialization
#     end
#
#     def name
#       "My addon name"
#     end
#   end
# end
# ```
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/addon.rb#22
class RubyLsp::Addon
  abstract!

  # source://ruby-lsp/lib/ruby_lsp/addon.rb#67
  sig { void }
  def initialize; end

  # Each addon should implement `MyAddon#activate` and use to perform any sort of initialization, such as
  # reading information into memory or even spawning a separate process
  #
  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/addon.rb#98
  sig { abstract.params(message_queue: ::Thread::Queue).void }
  def activate(message_queue); end

  # source://ruby-lsp/lib/ruby_lsp/addon.rb#72
  sig { params(error: ::StandardError).returns(T.self_type) }
  def add_error(error); end

  # source://ruby-lsp/lib/ruby_lsp/addon.rb#91
  sig { returns(::String) }
  def backtraces; end

  # Creates a new CodeLens listener. This method is invoked on every CodeLens request
  #
  # source://ruby-lsp/lib/ruby_lsp/addon.rb#116
  sig do
    overridable
      .params(
        uri: ::URI::Generic,
        dispatcher: ::Prism::Dispatcher
      ).returns(T.nilable(RubyLsp::Listener[T::Array[::LanguageServer::Protocol::Interface::CodeLens]]))
  end
  def create_code_lens_listener(uri, dispatcher); end

  # Creates a new Definition listener. This method is invoked on every Definition request
  #
  # source://ruby-lsp/lib/ruby_lsp/addon.rb#145
  sig do
    overridable
      .params(
        uri: ::URI::Generic,
        nesting: T::Array[::String],
        index: ::RubyIndexer::Index,
        dispatcher: ::Prism::Dispatcher
      ).returns(T.nilable(RubyLsp::Listener[T.nilable(T.any(::LanguageServer::Protocol::Interface::Location, T::Array[::LanguageServer::Protocol::Interface::Location]))]))
  end
  def create_definition_listener(uri, nesting, index, dispatcher); end

  # Creates a new DocumentSymbol listener. This method is invoked on every DocumentSymbol request
  #
  # source://ruby-lsp/lib/ruby_lsp/addon.rb#134
  sig do
    overridable
      .params(
        dispatcher: ::Prism::Dispatcher
      ).returns(T.nilable(RubyLsp::Listener[T::Array[::LanguageServer::Protocol::Interface::DocumentSymbol]]))
  end
  def create_document_symbol_listener(dispatcher); end

  # Creates a new Hover listener. This method is invoked on every Hover request
  #
  # source://ruby-lsp/lib/ruby_lsp/addon.rb#126
  sig do
    overridable
      .params(
        nesting: T::Array[::String],
        index: ::RubyIndexer::Index,
        dispatcher: ::Prism::Dispatcher
      ).returns(T.nilable(RubyLsp::Listener[T.nilable(::LanguageServer::Protocol::Interface::Hover)]))
  end
  def create_hover_listener(nesting, index, dispatcher); end

  # Each addon should implement `MyAddon#deactivate` and use to perform any clean up, like shutting down a
  # child process
  #
  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/addon.rb#103
  sig { abstract.void }
  def deactivate; end

  # source://ruby-lsp/lib/ruby_lsp/addon.rb#78
  sig { returns(T::Boolean) }
  def error?; end

  # source://ruby-lsp/lib/ruby_lsp/addon.rb#83
  sig { returns(::String) }
  def formatted_errors; end

  # Addons should override the `name` method to return the addon name
  #
  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/addon.rb#107
  sig { abstract.returns(::String) }
  def name; end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/addon.rb#39
    sig { returns(T::Array[::RubyLsp::Addon]) }
    def addons; end

    # Automatically track and instantiate addon classes
    #
    # source://ruby-lsp/lib/ruby_lsp/addon.rb#33
    sig { params(child_class: T.class_of(RubyLsp::Addon)).void }
    def inherited(child_class); end

    # Discovers and loads all addons. Returns the list of activated addons
    #
    # source://ruby-lsp/lib/ruby_lsp/addon.rb#45
    sig { params(message_queue: ::Thread::Queue).returns(T::Array[::RubyLsp::Addon]) }
    def load_addons(message_queue); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/utils.rb#7
RubyLsp::BUNDLE_PATH = T.let(T.unsafe(nil), String)

# source://ruby-lsp/lib/ruby_lsp/server.rb#7
RubyLsp::Constant = LanguageServer::Protocol::Constant

# source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#7
class RubyLsp::DependencyDetector
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#21
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#68
  sig { returns(T::Array[::String]) }
  def dependencies; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#28
  sig { returns(::String) }
  def detect_formatter; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#40
  sig { returns(::String) }
  def detect_test_library; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#63
  sig { returns(T::Boolean) }
  def detect_typechecker; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#12
  sig { returns(::String) }
  def detected_formatter; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#15
  sig { returns(::String) }
  def detected_test_library; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#58
  sig { params(gem_pattern: ::Regexp).returns(T::Boolean) }
  def direct_dependency?(gem_pattern); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#81
  sig { returns(T::Array[::String]) }
  def gemspec_dependencies; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#18
  sig { returns(T::Boolean) }
  def typechecker; end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/document.rb#5
class RubyLsp::Document
  abstract!

  # source://ruby-lsp/lib/ruby_lsp/document.rb#28
  sig { params(source: ::String, version: ::Integer, uri: ::URI::Generic, encoding: ::String).void }
  def initialize(source:, version:, uri:, encoding: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#49
  sig { params(other: ::RubyLsp::Document).returns(T::Boolean) }
  def ==(other); end

  # TODO: remove this method once all nonpositional requests have been migrated to the listener pattern
  #
  # source://ruby-lsp/lib/ruby_lsp/document.rb#61
  sig do
    type_parameters(:T)
      .params(
        request_name: ::String,
        block: T.proc.params(document: ::RubyLsp::Document).returns(T.type_parameter(:T))
      ).returns(T.type_parameter(:T))
  end
  def cache_fetch(request_name, &block); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#76
  sig { params(request_name: ::String).returns(T.untyped) }
  def cache_get(request_name); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#71
  sig { type_parameters(:T).params(request_name: ::String, value: T.type_parameter(:T)).returns(T.type_parameter(:T)) }
  def cache_set(request_name, value); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#44
  sig { returns(T::Array[::Prism::Comment]) }
  def comments; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#106
  sig { returns(::RubyLsp::Document::Scanner) }
  def create_scanner; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#127
  sig do
    params(
      node: ::Prism::Node,
      char_position: ::Integer,
      node_types: T::Array[T.class_of(Prism::Node)]
    ).returns([T.nilable(::Prism::Node), T.nilable(::Prism::Node), T::Array[::String]])
  end
  def locate(node, char_position, node_types: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#116
  sig do
    params(
      position: {line: ::Integer, character: ::Integer},
      node_types: T::Array[T.class_of(Prism::Node)]
    ).returns([T.nilable(::Prism::Node), T.nilable(::Prism::Node), T::Array[::String]])
  end
  def locate_node(position, node_types: T.unsafe(nil)); end

  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/document.rb#98
  sig { abstract.returns(::Prism::ParseResult) }
  def parse; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#16
  sig { returns(::Prism::ParseResult) }
  def parse_result; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#81
  sig do
    params(
      edits: T::Array[{range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}, text: ::String}],
      version: ::Integer
    ).void
  end
  def push_edits(edits, version:); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#19
  sig { returns(::String) }
  def source; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#101
  sig { returns(T::Boolean) }
  def syntax_error?; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#39
  sig { returns(::Prism::ProgramNode) }
  def tree; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#25
  sig { returns(::URI::Generic) }
  def uri; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#22
  sig { returns(::Integer) }
  def version; end
end

# source://ruby-lsp/lib/ruby_lsp/document.rb#13
RubyLsp::Document::EditShape = T.type_alias { {range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}, text: ::String} }

# source://ruby-lsp/lib/ruby_lsp/document.rb#11
RubyLsp::Document::PositionShape = T.type_alias { {line: ::Integer, character: ::Integer} }

# source://ruby-lsp/lib/ruby_lsp/document.rb#12
RubyLsp::Document::RangeShape = T.type_alias { {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}} }

# source://ruby-lsp/lib/ruby_lsp/document.rb#177
class RubyLsp::Document::Scanner
  # source://ruby-lsp/lib/ruby_lsp/document.rb#185
  sig { params(source: ::String, encoding: ::String).void }
  def initialize(source, encoding); end

  # Finds the character index inside the source string for a given line and column
  #
  # source://ruby-lsp/lib/ruby_lsp/document.rb#194
  sig { params(position: {line: ::Integer, character: ::Integer}).returns(::Integer) }
  def find_char_position(position); end

  # Subtract 1 for each character after 0xFFFF in the current line from the column position, so that we hit the
  # right character in the UTF-8 representation
  #
  # source://ruby-lsp/lib/ruby_lsp/document.rb#216
  sig { params(current_position: ::Integer, requested_position: ::Integer).returns(::Integer) }
  def utf_16_character_position_correction(current_position, requested_position); end
end

# source://ruby-lsp/lib/ruby_lsp/document.rb#180
RubyLsp::Document::Scanner::LINE_BREAK = T.let(T.unsafe(nil), Integer)

# After character 0xFFFF, UTF-16 considers characters to have length 2 and we have to account for that
#
# source://ruby-lsp/lib/ruby_lsp/document.rb#182
RubyLsp::Document::Scanner::SURROGATE_PAIR_START = T.let(T.unsafe(nil), Integer)

# This class dispatches a request execution to the right request class. No IO should happen anywhere here!
#
# source://ruby-lsp/lib/ruby_lsp/executor.rb#8
class RubyLsp::Executor
  # source://ruby-lsp/lib/ruby_lsp/executor.rb#12
  sig { params(store: ::RubyLsp::Store, message_queue: ::Thread::Queue).void }
  def initialize(store, message_queue); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#21
  sig { params(request: T::Hash[::Symbol, T.untyped]).returns(::RubyLsp::Result) }
  def execute(request); end

  private

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#522
  sig { params(id: ::String, title: ::String, percentage: ::Integer).void }
  def begin_progress(id, title, percentage: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#750
  sig { void }
  def check_formatter_is_available; end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#407
  sig do
    params(
      uri: ::URI::Generic,
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}},
      context: T::Hash[::Symbol, T.untyped]
    ).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::CodeAction]))
  end
  def code_action(uri, range, context); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#414
  sig { params(params: T::Hash[::Symbol, T.untyped]).returns(::LanguageServer::Protocol::Interface::CodeAction) }
  def code_action_resolve(params); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#476
  sig do
    params(
      uri: ::URI::Generic,
      position: {line: ::Integer, character: ::Integer}
    ).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::CompletionItem]))
  end
  def completion(uri, position); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#258
  sig do
    params(
      uri: ::URI::Generic,
      position: {line: ::Integer, character: ::Integer}
    ).returns(T.nilable(T.any(::LanguageServer::Protocol::Interface::Location, T::Array[::LanguageServer::Protocol::Interface::Location])))
  end
  def definition(uri, position); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#444
  sig do
    params(
      uri: ::URI::Generic
    ).returns(T.nilable(::LanguageServer::Protocol::Interface::FullDocumentDiagnosticReport))
  end
  def diagnostic(uri); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#185
  sig { params(changes: T::Array[{uri: ::String, type: ::Integer}]).returns(::Object) }
  def did_change_watched_files(changes); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#377
  sig do
    params(
      uri: ::URI::Generic,
      position: {line: ::Integer, character: ::Integer}
    ).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::DocumentHighlight]))
  end
  def document_highlight(uri, position); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#562
  sig { params(id: ::String).void }
  def end_progress(id); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#348
  sig { params(uri: ::URI::Generic).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::TextEdit])) }
  def formatting(uri); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#279
  sig do
    params(
      uri: ::URI::Generic,
      position: {line: ::Integer, character: ::Integer}
    ).returns(T.nilable(::LanguageServer::Protocol::Interface::Hover))
  end
  def hover(uri, position); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#578
  sig { params(options: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def initialize_request(options); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#388
  sig do
    params(
      uri: ::URI::Generic,
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}
    ).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::InlayHint]))
  end
  def inlay_hint(uri, range); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#367
  sig do
    params(
      uri: ::URI::Generic,
      position: {line: ::Integer, character: ::Integer},
      character: ::String
    ).returns(T::Array[::LanguageServer::Protocol::Interface::TextEdit])
  end
  def on_type_formatting(uri, position, character); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#210
  sig { void }
  def perform_initial_indexing; end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#545
  sig { params(id: ::String, percentage: ::Integer).void }
  def progress(id, percentage); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#37
  sig { params(request: T::Hash[::Symbol, T.untyped]).returns(T.untyped) }
  def run(request); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#328
  sig do
    params(
      uri: ::URI::Generic,
      positions: T::Array[{line: ::Integer, character: ::Integer}]
    ).returns(T.nilable(T::Array[T.nilable(::RubyLsp::Requests::Support::SelectionRange)]))
  end
  def selection_range(uri, positions); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#458
  sig do
    params(
      uri: ::URI::Generic,
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}
    ).returns(::LanguageServer::Protocol::Interface::SemanticTokens)
  end
  def semantic_tokens_range(uri, range); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#248
  sig do
    params(
      uri: ::URI::Generic,
      range: T.nilable({start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}})
    ).returns({ast: ::String})
  end
  def show_syntax_tree(uri, range); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#305
  sig do
    params(
      uri: ::URI::Generic,
      content_changes: T::Array[{range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}, text: ::String}],
      version: ::Integer
    ).returns(::Object)
  end
  def text_document_did_change(uri, content_changes, version); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#317
  sig { params(uri: ::URI::Generic).returns(::Object) }
  def text_document_did_close(uri); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#311
  sig { params(uri: ::URI::Generic, text: ::String, version: ::Integer).returns(::Object) }
  def text_document_did_open(uri, text, version); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#243
  sig { params(query: T.nilable(::String)).returns(T::Array[::LanguageServer::Protocol::Interface::WorkspaceSymbol]) }
  def workspace_symbol(query); end
end

# ExtensibleListener is an abstract class to be used by requests that accept addons.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/listener.rb#34
class RubyLsp::ExtensibleListener < ::RubyLsp::Listener
  extend T::Generic

  abstract!

  ResponseType = type_member

  # When inheriting from ExtensibleListener, the `super` of constructor must be called **after** the subclass's own
  # ivars have been initialized. This is because the constructor of ExtensibleListener calls
  # `initialize_external_listener` which may depend on the subclass's ivars.
  #
  # source://ruby-lsp/lib/ruby_lsp/listener.rb#46
  sig { params(dispatcher: ::Prism::Dispatcher).void }
  def initialize(dispatcher); end

  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/listener.rb#73
  sig { abstract.params(addon: ::RubyLsp::Addon).returns(T.nilable(RubyLsp::Listener[ResponseType])) }
  def initialize_external_listener(addon); end

  # Merge responses from all external listeners into the base listener's response. We do this to return a single
  # response to the editor including the results of all addons
  #
  # source://ruby-lsp/lib/ruby_lsp/listener.rb#60
  sig { void }
  def merge_external_listeners_responses!; end

  # Does nothing by default. Requests that accept addons should override this method to define how to merge responses
  # coming from external listeners
  #
  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/listener.rb#78
  sig { abstract.params(other: RubyLsp::Listener[T.untyped]).returns(T.self_type) }
  def merge_response!(other); end

  # source://ruby-lsp/lib/ruby_lsp/listener.rb#65
  sig { returns(ResponseType) }
  def response; end
end

# source://ruby-lsp/lib/ruby_lsp/server.rb#6
RubyLsp::Interface = LanguageServer::Protocol::Interface

# A request that will sit in the queue until it's executed
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#57
class RubyLsp::Job
  # source://ruby-lsp/lib/ruby_lsp/utils.rb#67
  sig { params(request: T::Hash[::Symbol, T.untyped], cancelled: T::Boolean).void }
  def initialize(request:, cancelled:); end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#73
  sig { void }
  def cancel; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#64
  sig { returns(T::Boolean) }
  def cancelled; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#61
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def request; end
end

# Listener is an abstract class to be used by requests for listening to events emitted when visiting an AST using the
# Prism::Dispatcher.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/listener.rb#7
class RubyLsp::Listener
  extend T::Generic
  include ::RubyLsp::Requests::Support::Common

  abstract!

  ResponseType = type_member

  # source://ruby-lsp/lib/ruby_lsp/listener.rb#18
  sig { params(dispatcher: ::Prism::Dispatcher).void }
  def initialize(dispatcher); end

  # Override this method with an attr_reader that returns the response of your listener. The listener should
  # accumulate results in a @response variable and then provide the reader so that it is accessible
  #
  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/listener.rb#30
  sig { abstract.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/listener.rb#23
  sig { returns(ResponseType) }
  def response; end
end

# A notification to be sent to the client
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#17
class RubyLsp::Message
  abstract!

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#30
  sig { params(message: ::String, params: ::Object).void }
  def initialize(message:, params:); end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#24
  sig { returns(::String) }
  def message; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#27
  sig { returns(::Object) }
  def params; end
end

# source://ruby-lsp/lib/ruby_lsp/utils.rb#36
class RubyLsp::Notification < ::RubyLsp::Message; end

# source://ruby-lsp/lib/ruby_lsp/parameter_scope.rb#5
class RubyLsp::ParameterScope
  # source://ruby-lsp/lib/ruby_lsp/parameter_scope.rb#12
  sig { params(parent: T.nilable(::RubyLsp::ParameterScope)).void }
  def initialize(parent = T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/parameter_scope.rb#18
  sig { params(name: T.any(::String, ::Symbol)).void }
  def <<(name); end

  # source://ruby-lsp/lib/ruby_lsp/parameter_scope.rb#28
  sig { params(name: T.any(::String, ::Symbol)).returns(T::Boolean) }
  def parameter?(name); end

  # source://ruby-lsp/lib/ruby_lsp/parameter_scope.rb#9
  sig { returns(T.nilable(::RubyLsp::ParameterScope)) }
  def parent; end

  # source://ruby-lsp/lib/ruby_lsp/parameter_scope.rb#23
  sig { params(name: T.any(::String, ::Symbol)).returns(::Symbol) }
  def type_for(name); end
end

# source://ruby-lsp/lib/ruby_lsp/utils.rb#37
class RubyLsp::Request < ::RubyLsp::Message; end

# Supported features
#
# - [DocumentSymbol](rdoc-ref:RubyLsp::Requests::DocumentSymbol)
# - [DocumentLink](rdoc-ref:RubyLsp::Requests::DocumentLink)
# - [Hover](rdoc-ref:RubyLsp::Requests::Hover)
# - [FoldingRange](rdoc-ref:RubyLsp::Requests::FoldingRanges)
# - [SelectionRange](rdoc-ref:RubyLsp::Requests::SelectionRanges)
# - [SemanticHighlighting](rdoc-ref:RubyLsp::Requests::SemanticHighlighting)
# - [Formatting](rdoc-ref:RubyLsp::Requests::Formatting)
# - [OnTypeFormatting](rdoc-ref:RubyLsp::Requests::OnTypeFormatting)
# - [Diagnostic](rdoc-ref:RubyLsp::Requests::Diagnostics)
# - [CodeAction](rdoc-ref:RubyLsp::Requests::CodeActions)
# - [CodeActionResolve](rdoc-ref:RubyLsp::Requests::CodeActionResolve)
# - [DocumentHighlight](rdoc-ref:RubyLsp::Requests::DocumentHighlight)
# - [InlayHint](rdoc-ref:RubyLsp::Requests::InlayHints)
# - [Completion](rdoc-ref:RubyLsp::Requests::Completion)
# - [CodeLens](rdoc-ref:RubyLsp::Requests::CodeLens)
# - [Definition](rdoc-ref:RubyLsp::Requests::Definition)
# - [ShowSyntaxTree](rdoc-ref:RubyLsp::Requests::ShowSyntaxTree)
# - [WorkspaceSymbol](rdoc-ref:RubyLsp::Requests::WorkspaceSymbol)
#
# source://ruby-lsp/lib/ruby_lsp/requests.rb#26
module RubyLsp::Requests; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/requests/base_request.rb#7
class RubyLsp::Requests::BaseRequest < ::Prism::Visitor
  include ::RubyLsp::Requests::Support::Common

  abstract!

  # source://ruby-lsp/lib/ruby_lsp/requests/base_request.rb#15
  sig { params(document: ::RubyLsp::Document).void }
  def initialize(document); end

  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/base_request.rb#21
  sig { abstract.returns(::Object) }
  def run; end
end

# ![Code action resolve demo](../../code_action_resolve.gif)
#
# The [code action resolve](https://microsoft.github.io/language-server-protocol/specification#codeAction_resolve)
# request is used to to resolve the edit field for a given code action, if it is not already provided in the
# textDocument/codeAction response. We can use it for scenarios that require more computation such as refactoring.
#
# # Example: Extract to variable
#
# ```ruby
# # Before:
# 1 + 1 # Select the text and use Refactor: Extract Variable
#
# # After:
# new_variable = 1 + 1
# new_variable
#
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#24
class RubyLsp::Requests::CodeActionResolve < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#38
  sig { params(document: ::RubyLsp::Document, code_action: T::Hash[::Symbol, T.untyped]).void }
  def initialize(document, code_action); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#45
  sig do
    override
      .returns(T.any(::LanguageServer::Protocol::Interface::CodeAction, ::RubyLsp::Requests::CodeActionResolve::Error))
  end
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#141
  sig do
    params(
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}},
      new_text: ::String
    ).returns(::LanguageServer::Protocol::Interface::TextEdit)
  end
  def create_text_edit(range, new_text); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#28
class RubyLsp::Requests::CodeActionResolve::CodeActionError < ::StandardError; end

# source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#30
class RubyLsp::Requests::CodeActionResolve::Error < ::T::Enum
  enums do
    EmptySelection = new
    InvalidTargetRange = new
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#26
RubyLsp::Requests::CodeActionResolve::NEW_VARIABLE_NAME = T.let(T.unsafe(nil), String)

# ![Code actions demo](../../code_actions.gif)
#
# The [code actions](https://microsoft.github.io/language-server-protocol/specification#textDocument_codeAction)
# request informs the editor of RuboCop quick fixes that can be applied. These are accessible by hovering over a
# specific diagnostic.
#
# # Example
#
# ```ruby
# def say_hello
# puts "Hello" # --> code action: quick fix indentation
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#19
class RubyLsp::Requests::CodeActions < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#29
  sig do
    params(
      document: ::RubyLsp::Document,
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}},
      context: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(document, range, context); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#38
  sig { override.returns(T.nilable(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::CodeAction]))) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#59
  sig do
    params(
      range: T.nilable({start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}})
    ).returns(T::Boolean)
  end
  def cover?(range); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#67
  sig do
    params(
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}},
      uri: ::URI::Generic
    ).returns(::LanguageServer::Protocol::Interface::CodeAction)
  end
  def refactor_code_action(range, uri); end
end

# ![Code lens demo](../../code_lens.gif)
#
# The
# [code lens](https://microsoft.github.io/language-server-protocol/specification#textDocument_codeLens)
# request informs the editor of runnable commands such as tests
#
# # Example
#
# ```ruby
# # Run
# class Test < Minitest::Test
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#21
class RubyLsp::Requests::CodeLens < ::RubyLsp::ExtensibleListener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::CodeLens] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#51
  sig { params(uri: ::URI::Generic, dispatcher: ::Prism::Dispatcher).void }
  def initialize(uri, dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#48
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#154
  sig { override.params(addon: ::RubyLsp::Addon).returns(T.nilable(RubyLsp::Listener[ResponseType])) }
  def initialize_external_listener(addon); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#159
  sig { override.params(other: RubyLsp::Listener[ResponseType]).returns(T.self_type) }
  def merge_response!(other); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#119
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#148
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_leave(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#74
  sig { params(node: ::Prism::ClassNode).void }
  def on_class_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#93
  sig { params(node: ::Prism::ClassNode).void }
  def on_class_node_leave(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#100
  sig { params(node: ::Prism::DefNode).void }
  def on_def_node_enter(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#244
  sig { params(node: ::Prism::CallNode, remote: ::String).void }
  def add_open_gem_remote_code_lens(node, remote); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#167
  sig { params(node: ::Prism::Node, name: ::String, command: ::String, kind: ::Symbol).void }
  def add_test_code_lens(node, name:, command:, kind:); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#222
  sig { params(class_name: ::String, method_name: T.nilable(::String)).returns(::String) }
  def generate_test_command(class_name:, method_name: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#212
  sig { params(gem_name: ::Prism::StringNode).returns(T.nilable(::String)) }
  def resolve_gem_remote(gem_name); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#44
RubyLsp::Requests::CodeLens::ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#27
RubyLsp::Requests::CodeLens::BASE_COMMAND = T.let(T.unsafe(nil), String)

# source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#36
RubyLsp::Requests::CodeLens::GEMFILE_NAME = T.let(T.unsafe(nil), String)

# source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#45
RubyLsp::Requests::CodeLens::SUPPORTED_TEST_LIBRARIES = T.let(T.unsafe(nil), Array)

# ![Completion demo](../../completion.gif)
#
# The [completion](https://microsoft.github.io/language-server-protocol/specification#textDocument_completion)
# suggests possible completions according to what the developer is typing.
#
# Currently supported targets:
# - Classes
# - Modules
# - Constants
# - Require paths
# - Methods invoked on self only
#
# # Example
#
# ```ruby
# require "ruby_lsp/requests" # --> completion: suggests `base_request`, `code_actions`, ...
#
# RubyLsp::Requests:: # --> completion: suggests `Completion`, `Hover`, ...
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#25
class RubyLsp::Requests::Completion < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::CompletionItem] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#41
  sig { params(index: ::RubyIndexer::Index, nesting: T::Array[::String], dispatcher: ::Prism::Dispatcher).void }
  def initialize(index, nesting, dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#32
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#127
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_enter(node); end

  # Handle completion on namespaced constant references (e.g. `Foo::Bar`)
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#84
  sig { params(node: ::Prism::ConstantPathNode).void }
  def on_constant_path_node_enter(node); end

  # Handle completion on regular constant references (e.g. `Bar`)
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#65
  sig { params(node: ::Prism::ConstantReadNode).void }
  def on_constant_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#57
  sig { params(node: ::Prism::StringNode).void }
  def on_string_node_enter(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#173
  sig do
    params(
      label: ::String,
      node: ::Prism::StringNode
    ).returns(::LanguageServer::Protocol::Interface::CompletionItem)
  end
  def build_completion(label, node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#196
  sig do
    params(
      real_name: ::String,
      incomplete_name: ::String,
      node: ::Prism::Node,
      entries: T::Array[::RubyIndexer::Entry],
      top_level: T::Boolean
    ).returns(::LanguageServer::Protocol::Interface::CompletionItem)
  end
  def build_entry_completion(real_name, incomplete_name, node, entries, top_level); end

  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#155
  sig do
    params(
      entry: ::RubyIndexer::Entry::Member,
      node: ::Prism::CallNode
    ).returns(::LanguageServer::Protocol::Interface::CompletionItem)
  end
  def build_method_completion(entry, node); end

  # Check if there are any conflicting names for `entry_name`, which would require us to use a top level reference.
  # For example:
  #
  # ```ruby
  # class Bar; end
  #
  # module Foo
  #   class Bar; end
  #
  #   # in this case, the completion for `Bar` conflicts with `Foo::Bar`, so we can't suggest `Bar` as the
  #   # completion, but instead need to suggest `::Bar`
  #   B
  # end
  # ```
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/completion.rb#280
  sig { params(entry_name: ::String).returns(T::Boolean) }
  def top_level?(entry_name); end
end

# ![Definition demo](../../definition.gif)
#
# The [definition
# request](https://microsoft.github.io/language-server-protocol/specification#textDocument_definition) jumps to the
# definition of the symbol under the cursor.
#
# Currently supported targets:
# - Classes
# - Modules
# - Constants
# - Require paths
# - Methods invoked on self only
#
# # Example
#
# ```ruby
# require "some_gem/file" # <- Request go to definition on this string will take you to the file
# Product.new # <- Request go to definition on this class name will take you to its declaration.
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#25
class RubyLsp::Requests::Definition < ::RubyLsp::ExtensibleListener
  extend T::Generic

  ResponseType = type_member { { fixed: T.nilable(T.any(::LanguageServer::Protocol::Interface::Location, T::Array[::LanguageServer::Protocol::Interface::Location])) } }

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#42
  sig do
    params(
      uri: ::URI::Generic,
      nesting: T::Array[::String],
      index: ::RubyIndexer::Index,
      dispatcher: ::Prism::Dispatcher
    ).void
  end
  def initialize(uri, nesting, index, dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#32
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#59
  sig { override.params(addon: ::RubyLsp::Addon).returns(T.nilable(RubyLsp::Listener[ResponseType])) }
  def initialize_external_listener(addon); end

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#64
  sig { override.params(other: RubyLsp::Listener[ResponseType]).returns(T.self_type) }
  def merge_response!(other); end

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#80
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#91
  sig { params(node: ::Prism::ConstantPathNode).void }
  def on_constant_path_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#96
  sig { params(node: ::Prism::ConstantReadNode).void }
  def on_constant_read_node_enter(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#168
  sig { params(value: ::String).void }
  def find_in_index(value); end

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#103
  sig { params(node: ::Prism::CallNode).void }
  def handle_method_definition(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/definition.rb#126
  sig { params(node: ::Prism::CallNode).void }
  def handle_require_definition(node); end
end

# ![Diagnostics demo](../../diagnostics.gif)
#
# The
# [diagnostics](https://microsoft.github.io/language-server-protocol/specification#textDocument_publishDiagnostics)
# request informs the editor of RuboCop offenses for a given file.
#
# # Example
#
# ```ruby
# def say_hello
# puts "Hello" # --> diagnostics: incorrect indentation
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/diagnostics.rb#21
class RubyLsp::Requests::Diagnostics < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/diagnostics.rb#25
  sig { params(document: ::RubyLsp::Document).void }
  def initialize(document); end

  # source://ruby-lsp/lib/ruby_lsp/requests/diagnostics.rb#32
  sig { override.returns(T.nilable(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::Diagnostic]))) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/diagnostics.rb#43
  sig { returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::Diagnostic])) }
  def syntax_error_diagnostics; end
end

# ![Document highlight demo](../../document_highlight.gif)
#
# The [document highlight](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight)
# informs the editor all relevant elements of the currently pointed item for highlighting. For example, when
# the cursor is on the `F` of the constant `FOO`, the editor should identify other occurrences of `FOO`
# and highlight them.
#
# For writable elements like constants or variables, their read/write occurrences should be highlighted differently.
# This is achieved by sending different "kind" attributes to the editor (2 for read and 3 for write).
#
# # Example
#
# ```ruby
# FOO = 1 # should be highlighted as "write"
#
# def foo
#   FOO # should be highlighted as "read"
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#25
class RubyLsp::Requests::DocumentHighlight < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::DocumentHighlight] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#119
  sig do
    params(
      target: T.nilable(::Prism::Node),
      parent: T.nilable(::Prism::Node),
      dispatcher: ::Prism::Dispatcher
    ).void
  end
  def initialize(target, parent, dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#110
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#260
  sig { params(node: ::Prism::BlockParameterNode).void }
  def on_block_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#204
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#274
  sig { params(node: ::Prism::ClassNode).void }
  def on_class_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#444
  sig { params(node: ::Prism::ClassVariableAndWriteNode).void }
  def on_class_variable_and_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#437
  sig { params(node: ::Prism::ClassVariableOperatorWriteNode).void }
  def on_class_variable_operator_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#430
  sig { params(node: ::Prism::ClassVariableOrWriteNode).void }
  def on_class_variable_or_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#316
  sig { params(node: ::Prism::ClassVariableReadNode).void }
  def on_class_variable_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#246
  sig { params(node: ::Prism::ClassVariableTargetNode).void }
  def on_class_variable_target_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#423
  sig { params(node: ::Prism::ClassVariableWriteNode).void }
  def on_class_variable_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#500
  sig { params(node: ::Prism::ConstantAndWriteNode).void }
  def on_constant_and_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#465
  sig { params(node: ::Prism::ConstantOperatorWriteNode).void }
  def on_constant_operator_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#458
  sig { params(node: ::Prism::ConstantOrWriteNode).void }
  def on_constant_or_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#344
  sig { params(node: ::Prism::ConstantPathAndWriteNode).void }
  def on_constant_path_and_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#295
  sig { params(node: ::Prism::ConstantPathNode).void }
  def on_constant_path_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#351
  sig { params(node: ::Prism::ConstantPathOperatorWriteNode).void }
  def on_constant_path_operator_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#337
  sig { params(node: ::Prism::ConstantPathOrWriteNode).void }
  def on_constant_path_or_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#232
  sig { params(node: ::Prism::ConstantPathTargetNode).void }
  def on_constant_path_target_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#330
  sig { params(node: ::Prism::ConstantPathWriteNode).void }
  def on_constant_path_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#302
  sig { params(node: ::Prism::ConstantReadNode).void }
  def on_constant_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#239
  sig { params(node: ::Prism::ConstantTargetNode).void }
  def on_constant_target_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#451
  sig { params(node: ::Prism::ConstantWriteNode).void }
  def on_constant_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#211
  sig { params(node: ::Prism::DefNode).void }
  def on_def_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#521
  sig { params(node: ::Prism::GlobalVariableAndWriteNode).void }
  def on_global_variable_and_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#528
  sig { params(node: ::Prism::GlobalVariableOperatorWriteNode).void }
  def on_global_variable_operator_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#514
  sig { params(node: ::Prism::GlobalVariableOrWriteNode).void }
  def on_global_variable_or_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#323
  sig { params(node: ::Prism::GlobalVariableReadNode).void }
  def on_global_variable_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#218
  sig { params(node: ::Prism::GlobalVariableTargetNode).void }
  def on_global_variable_target_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#507
  sig { params(node: ::Prism::GlobalVariableWriteNode).void }
  def on_global_variable_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#486
  sig { params(node: ::Prism::InstanceVariableAndWriteNode).void }
  def on_instance_variable_and_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#493
  sig { params(node: ::Prism::InstanceVariableOperatorWriteNode).void }
  def on_instance_variable_operator_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#479
  sig { params(node: ::Prism::InstanceVariableOrWriteNode).void }
  def on_instance_variable_or_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#309
  sig { params(node: ::Prism::InstanceVariableReadNode).void }
  def on_instance_variable_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#225
  sig { params(node: ::Prism::InstanceVariableTargetNode).void }
  def on_instance_variable_target_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#472
  sig { params(node: ::Prism::InstanceVariableWriteNode).void }
  def on_instance_variable_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#394
  sig { params(node: ::Prism::KeywordRestParameterNode).void }
  def on_keyword_rest_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#402
  sig { params(node: ::Prism::LocalVariableAndWriteNode).void }
  def on_local_variable_and_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#409
  sig { params(node: ::Prism::LocalVariableOperatorWriteNode).void }
  def on_local_variable_operator_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#416
  sig { params(node: ::Prism::LocalVariableOrWriteNode).void }
  def on_local_variable_or_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#288
  sig { params(node: ::Prism::LocalVariableReadNode).void }
  def on_local_variable_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#253
  sig { params(node: ::Prism::LocalVariableTargetNode).void }
  def on_local_variable_target_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#358
  sig { params(node: ::Prism::LocalVariableWriteNode).void }
  def on_local_variable_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#281
  sig { params(node: ::Prism::ModuleNode).void }
  def on_module_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#372
  sig { params(node: ::Prism::OptionalKeywordParameterNode).void }
  def on_optional_keyword_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#387
  sig { params(node: ::Prism::OptionalParameterNode).void }
  def on_optional_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#365
  sig { params(node: ::Prism::RequiredKeywordParameterNode).void }
  def on_required_keyword_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#267
  sig { params(node: ::Prism::RequiredParameterNode).void }
  def on_required_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#379
  sig { params(node: ::Prism::RestParameterNode).void }
  def on_rest_parameter_node_enter(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#542
  sig { params(kind: ::Integer, location: ::Prism::Location).void }
  def add_highlight(kind, location); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#537
  sig { params(node: ::Prism::Node, classes: T::Array[T.class_of(Prism::Node)]).returns(T.nilable(T::Boolean)) }
  def matches?(node, classes); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#547
  sig { params(node: T.nilable(::Prism::Node)).returns(T.nilable(::String)) }
  def node_value(node); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#78
RubyLsp::Requests::DocumentHighlight::CLASS_VARIABLE_NODES = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#54
RubyLsp::Requests::DocumentHighlight::CONSTANT_NODES = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#66
RubyLsp::Requests::DocumentHighlight::CONSTANT_PATH_NODES = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#30
RubyLsp::Requests::DocumentHighlight::GLOBAL_VARIABLE_NODES = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#42
RubyLsp::Requests::DocumentHighlight::INSTANCE_VARIABLE_NODES = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#90
RubyLsp::Requests::DocumentHighlight::LOCAL_NODES = T.let(T.unsafe(nil), Array)

# ![Document link demo](../../document_link.gif)
#
# The [document link](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentLink)
# makes `# source://PATH_TO_FILE#line` comments in a Ruby/RBI file clickable if the file exists.
# When the user clicks the link, it'll open that location.
#
# # Example
#
# ```ruby
# # source://syntax_tree/3.2.1/lib/syntax_tree.rb#51 <- it will be clickable and will take the user to that location
# def format(source, maxwidth = T.unsafe(nil))
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#21
class RubyLsp::Requests::DocumentLink < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::DocumentLink] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#85
  sig { params(uri: ::URI::Generic, comments: T::Array[::Prism::Comment], dispatcher: ::Prism::Dispatcher).void }
  def initialize(uri, comments, dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#76
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#117
  sig { params(node: ::Prism::ClassNode).void }
  def on_class_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#132
  sig { params(node: ::Prism::ConstantPathWriteNode).void }
  def on_constant_path_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#127
  sig { params(node: ::Prism::ConstantWriteNode).void }
  def on_constant_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#112
  sig { params(node: ::Prism::DefNode).void }
  def on_def_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#122
  sig { params(node: ::Prism::ModuleNode).void }
  def on_module_node_enter(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#139
  sig { params(node: ::Prism::Node).void }
  def extract_document_link(node); end

  # Try to figure out the gem version for a source:// link. The order of precedence is:
  # 1. The version in the URI
  # 2. The version in the RBI file name
  # 3. The version from the gemspec
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#165
  sig { params(uri: ::URI::Source).returns(T.nilable(::String)) }
  def resolve_version(uri); end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#38
    sig { returns(T::Hash[::String, T::Hash[::String, T::Hash[::String, ::String]]]) }
    def gem_paths; end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#27
RubyLsp::Requests::DocumentLink::GEM_TO_VERSION_MAP = T.let(T.unsafe(nil), Hash)

# ![Document symbol demo](../../document_symbol.gif)
#
# The [document
# symbol](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentSymbol) request
# informs the editor of all the important symbols, such as classes, variables, and methods, defined in a file. With
# this information, the editor can populate breadcrumbs, file outline and allow for fuzzy symbol searches.
#
# In VS Code, fuzzy symbol search can be accessed by opening the command palette and inserting an `@` symbol.
#
# # Example
#
# ```ruby
# class Person # --> document symbol: class
#   attr_reader :age # --> document symbol: field
#
#   def initialize
#     @age = 0 # --> document symbol: variable
#   end
#
#   def age # --> document symbol: method
#   end
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#29
class RubyLsp::Requests::DocumentSymbol < ::RubyLsp::ExtensibleListener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::DocumentSymbol] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#53
  sig { params(dispatcher: ::Prism::Dispatcher).void }
  def initialize(dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#50
  sig { override.returns(T::Array[::LanguageServer::Protocol::Interface::DocumentSymbol]) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#82
  sig { override.params(addon: ::RubyLsp::Addon).returns(T.nilable(RubyLsp::Listener[ResponseType])) }
  def initialize_external_listener(addon); end

  # Merges responses from other listeners
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#88
  sig { override.params(other: RubyLsp::Listener[ResponseType]).returns(T.self_type) }
  def merge_response!(other); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#126
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#94
  sig { params(node: ::Prism::ClassNode).void }
  def on_class_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#104
  sig { params(node: ::Prism::ClassNode).void }
  def on_class_node_leave(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#224
  sig { params(node: ::Prism::ClassVariableWriteNode).void }
  def on_class_variable_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#148
  sig { params(node: ::Prism::ConstantPathWriteNode).void }
  def on_constant_path_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#158
  sig { params(node: ::Prism::ConstantWriteNode).void }
  def on_constant_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#183
  sig { params(node: ::Prism::DefNode).void }
  def on_def_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#168
  sig { params(node: ::Prism::DefNode).void }
  def on_def_node_leave(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#214
  sig { params(node: ::Prism::InstanceVariableWriteNode).void }
  def on_instance_variable_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#173
  sig { params(node: ::Prism::ModuleNode).void }
  def on_module_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#209
  sig { params(node: ::Prism::ModuleNode).void }
  def on_module_node_leave(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#109
  sig { params(node: ::Prism::SingletonClassNode).void }
  def on_singleton_class_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#121
  sig { params(node: ::Prism::SingletonClassNode).void }
  def on_singleton_class_node_leave(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#243
  sig do
    params(
      name: ::String,
      kind: ::Integer,
      range_location: ::Prism::Location,
      selection_range_location: ::Prism::Location
    ).returns(::LanguageServer::Protocol::Interface::DocumentSymbol)
  end
  def create_document_symbol(name:, kind:, range_location:, selection_range_location:); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#35
RubyLsp::Requests::DocumentSymbol::ATTR_ACCESSORS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#37
class RubyLsp::Requests::DocumentSymbol::SymbolHierarchyRoot
  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#44
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#41
  sig { returns(T::Array[::LanguageServer::Protocol::Interface::DocumentSymbol]) }
  def children; end
end

# ![Folding ranges demo](../../folding_ranges.gif)
#
# The [folding ranges](https://microsoft.github.io/language-server-protocol/specification#textDocument_foldingRange)
# request informs the editor of the ranges where and how code can be folded.
#
# # Example
#
# ```ruby
# def say_hello # <-- folding range start
#   puts "Hello"
# end # <-- folding range end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#18
class RubyLsp::Requests::FoldingRanges < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::FoldingRange] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#25
  sig { params(comments: T::Array[::Prism::Comment], dispatcher: ::Prism::Dispatcher).void }
  def initialize(comments, dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#62
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#101
  sig { params(node: ::Prism::ArrayNode).void }
  def on_array_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#171
  sig { params(node: ::Prism::BeginNode).void }
  def on_begin_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#106
  sig { params(node: ::Prism::BlockNode).void }
  def on_block_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#191
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#116
  sig { params(node: ::Prism::CaseMatchNode).void }
  def on_case_match_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#111
  sig { params(node: ::Prism::CaseNode).void }
  def on_case_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#121
  sig { params(node: ::Prism::ClassNode).void }
  def on_class_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#176
  sig { params(node: ::Prism::DefNode).void }
  def on_def_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#161
  sig { params(node: ::Prism::ElseNode).void }
  def on_else_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#166
  sig { params(node: ::Prism::EnsureNode).void }
  def on_ensure_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#131
  sig { params(node: ::Prism::ForNode).void }
  def on_for_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#136
  sig { params(node: ::Prism::HashNode).void }
  def on_hash_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#73
  sig { params(node: ::Prism::IfNode).void }
  def on_if_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#78
  sig { params(node: ::Prism::InNode).void }
  def on_in_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#93
  sig { params(node: ::Prism::InterpolatedStringNode).void }
  def on_interpolated_string_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#204
  sig { params(node: ::Prism::LambdaNode).void }
  def on_lambda_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#126
  sig { params(node: ::Prism::ModuleNode).void }
  def on_module_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#83
  sig { params(node: ::Prism::RescueNode).void }
  def on_rescue_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#141
  sig { params(node: ::Prism::SingletonClassNode).void }
  def on_singleton_class_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#146
  sig { params(node: ::Prism::UnlessNode).void }
  def on_unless_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#151
  sig { params(node: ::Prism::UntilNode).void }
  def on_until_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#88
  sig { params(node: ::Prism::WhenNode).void }
  def on_when_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#156
  sig { params(node: ::Prism::WhileNode).void }
  def on_while_node_enter(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#271
  sig { params(start_line: ::Integer, end_line: ::Integer).void }
  def add_lines_range(start_line, end_line); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#265
  sig { params(node: ::Prism::Node).void }
  def add_simple_range(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#254
  sig { params(node: T.any(::Prism::IfNode, ::Prism::InNode, ::Prism::RescueNode, ::Prism::WhenNode)).void }
  def add_statements_range(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#227
  sig { void }
  def emit_requires_range; end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#211
  sig { void }
  def push_comment_ranges; end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#240
  sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
  def require?(node); end
end

# ![Formatting symbol demo](../../formatting.gif)
#
# The [formatting](https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting)
# request uses RuboCop to fix auto-correctable offenses in the document. This requires enabling format on save and
# registering the ruby-lsp as the Ruby formatter.
#
# The `rubyLsp.formatter` setting specifies which formatter to use.
# If set to `auto` then it behaves as follows:
# * It will use RuboCop if it is part of the bundle.
# * If RuboCop is not available, and `syntax_tree` is a direct dependency, it will use that.
# * Otherwise, no formatting will be applied.
#
# # Example
#
# ```ruby
# def say_hello
# puts "Hello" # --> formatting: fixes the indentation on save
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#28
class RubyLsp::Requests::Formatting < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#57
  sig { params(document: ::RubyLsp::Document, formatter: ::String).void }
  def initialize(document, formatter: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#65
  sig { override.returns(T.nilable(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::TextEdit]))) }
  def run; end

  private

  # @raise [InvalidFormatter]
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#89
  sig { returns(T.nilable(::String)) }
  def formatted_file; end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#38
    sig { returns(T::Hash[::String, ::RubyLsp::Requests::Support::FormatterRunner]) }
    def formatters; end

    # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#41
    sig { params(identifier: ::String, instance: ::RubyLsp::Requests::Support::FormatterRunner).void }
    def register_formatter(identifier, instance); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#29
class RubyLsp::Requests::Formatting::Error < ::StandardError; end

# source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#30
class RubyLsp::Requests::Formatting::InvalidFormatter < ::StandardError; end

# ![Hover demo](../../hover.gif)
#
# The [hover request](https://microsoft.github.io/language-server-protocol/specification#textDocument_hover)
# displays the documentation for the symbol currently under the cursor.
#
# # Example
#
# ```ruby
# String # -> Hovering over the class reference will show all declaration locations and the documentation
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#16
class RubyLsp::Requests::Hover < ::RubyLsp::ExtensibleListener
  extend T::Generic

  ResponseType = type_member { { fixed: T.nilable(::LanguageServer::Protocol::Interface::Hover) } }

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#42
  sig { params(index: ::RubyIndexer::Index, nesting: T::Array[::String], dispatcher: ::Prism::Dispatcher).void }
  def initialize(index, nesting, dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#33
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#58
  sig { override.params(addon: ::RubyLsp::Addon).returns(T.nilable(RubyLsp::Listener[ResponseType])) }
  def initialize_external_listener(addon); end

  # Merges responses from other hover listeners
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#64
  sig { override.params(other: RubyLsp::Listener[ResponseType]).returns(T.self_type) }
  def merge_response!(other); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#99
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#92
  sig { params(node: ::Prism::ConstantPathNode).void }
  def on_constant_path_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#78
  sig { params(node: ::Prism::ConstantReadNode).void }
  def on_constant_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#85
  sig { params(node: ::Prism::ConstantWriteNode).void }
  def on_constant_write_node_enter(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#120
  sig { params(name: ::String, location: ::Prism::Location).void }
  def generate_hover(name, location); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#22
RubyLsp::Requests::Hover::ALLOWED_TARGETS = T.let(T.unsafe(nil), Array)

# ![Inlay hint demo](../../inlay_hints.gif)
#
# [Inlay hints](https://microsoft.github.io/language-server-protocol/specification#textDocument_inlayHint)
# are labels added directly in the code that explicitly show the user something that might
# otherwise just be implied.
#
# # Example
#
# ```ruby
# begin
#   puts "do something that might raise"
# rescue # Label "StandardError" goes here as a bare rescue implies rescuing StandardError
#   puts "handle some rescue"
# end
# ```
#
# # Example
#
# ```ruby
# var = "foo"
# {
#   var: var, # Label "var" goes here in cases where the value is omitted
#   a: "hello",
# }
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#31
class RubyLsp::Requests::InlayHints < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::InlayHint] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#43
  sig { params(range: T::Range[::Integer], dispatcher: ::Prism::Dispatcher).void }
  def initialize(range, dispatcher); end

  # source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#40
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#68
  sig { params(node: ::Prism::ImplicitNode).void }
  def on_implicit_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#53
  sig { params(node: ::Prism::RescueNode).void }
  def on_rescue_node_enter(node); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#37
RubyLsp::Requests::InlayHints::RESCUE_STRING_LENGTH = T.let(T.unsafe(nil), Integer)

# ![On type formatting demo](../../on_type_formatting.gif)
#
# The [on type formatting](https://microsoft.github.io/language-server-protocol/specification#textDocument_onTypeFormatting)
# request formats code as the user is typing. For example, automatically adding `end` to class definitions.
#
# # Example
#
# ```ruby
# class Foo # <-- upon adding a line break, on type formatting is triggered
#   # <-- cursor ends up here
# end # <-- end is automatically added
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#18
class RubyLsp::Requests::OnTypeFormatting < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#30
  sig do
    params(
      document: ::RubyLsp::Document,
      position: {line: ::Integer, character: ::Integer},
      trigger_character: ::String
    ).void
  end
  def initialize(document, position, trigger_character); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#44
  sig { override.returns(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::TextEdit])) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#145
  sig { params(text: ::String, position: {line: ::Integer, character: ::Integer}).void }
  def add_edit_with_text(text, position = T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#177
  sig { params(line: ::String).returns(::Integer) }
  def find_indentation(line); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#140
  sig { params(spaces: ::String).void }
  def handle_comment_line(spaces); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#102
  sig { void }
  def handle_curly_brace; end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#132
  sig { params(delimiter: ::String).void }
  def handle_heredoc_end(delimiter); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#71
  sig { void }
  def handle_pipe; end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#110
  sig { void }
  def handle_statement_end; end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#158
  sig { params(line: ::Integer, character: ::Integer).void }
  def move_cursor_to(line, character); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#21
RubyLsp::Requests::OnTypeFormatting::END_REGEXES = T.let(T.unsafe(nil), Array)

# ![Selection ranges demo](../../selection_ranges.gif)
#
# The [selection ranges](https://microsoft.github.io/language-server-protocol/specification#textDocument_selectionRange)
# request informs the editor of ranges that the user may want to select based on the location(s)
# of their cursor(s).
#
# Trigger this request with: Ctrl + Shift + -> or Ctrl + Shift + <-
#
# Note that if using VSCode Neovim, you will need to be in Insert mode for this to work correctly.
#
# # Example
#
# ```ruby
# def foo # --> The next selection range encompasses the entire method definition.
#   puts "Hello, world!" # --> Cursor is on this line
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#23
class RubyLsp::Requests::SelectionRanges
  include ::RubyLsp::Requests::Support::Common

  # source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#27
  sig { params(document: ::RubyLsp::Document).void }
  def initialize(document); end

  # source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#34
  sig { returns(T.all(::Object, T::Array[::RubyLsp::Requests::Support::SelectionRange])) }
  def run; end
end

# ![Semantic highlighting demo](../../semantic_highlighting.gif)
#
# The [semantic
# highlighting](https://microsoft.github.io/language-server-protocol/specification#textDocument_semanticTokens)
# request informs the editor of the correct token types to provide consistent and accurate highlighting for themes.
#
# # Example
#
# ```ruby
# def foo
#   var = 1 # --> semantic highlighting: local variable
#   some_invocation # --> semantic highlighting: method invocation
#   var # --> semantic highlighting: local variable
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#21
class RubyLsp::Requests::SemanticHighlighting < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::RubyLsp::Requests::SemanticHighlighting::SemanticToken] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#111
  sig { params(dispatcher: ::Prism::Dispatcher, range: T.nilable(T::Range[::Integer])).void }
  def initialize(dispatcher, range: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#108
  sig { override.returns(ResponseType) }
  def _response; end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#257
  sig { params(node: ::Prism::BlockLocalVariableNode).void }
  def on_block_local_variable_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#247
  sig { params(node: ::Prism::BlockNode).void }
  def on_block_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#252
  sig { params(node: ::Prism::BlockNode).void }
  def on_block_node_leave(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#262
  sig { params(node: ::Prism::BlockParameterNode).void }
  def on_block_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#156
  sig { params(node: ::Prism::CallNode).void }
  def on_call_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#385
  sig { params(node: ::Prism::ClassNode).void }
  def on_class_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#206
  sig { params(node: ::Prism::ConstantAndWriteNode).void }
  def on_constant_and_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#213
  sig { params(node: ::Prism::ConstantOperatorWriteNode).void }
  def on_constant_operator_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#220
  sig { params(node: ::Prism::ConstantOrWriteNode).void }
  def on_constant_or_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#188
  sig { params(node: ::Prism::ConstantReadNode).void }
  def on_constant_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#227
  sig { params(node: ::Prism::ConstantTargetNode).void }
  def on_constant_target_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#199
  sig { params(node: ::Prism::ConstantWriteNode).void }
  def on_constant_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#234
  sig { params(node: ::Prism::DefNode).void }
  def on_def_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#242
  sig { params(node: ::Prism::DefNode).void }
  def on_def_node_leave(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#286
  sig { params(node: ::Prism::KeywordRestParameterNode).void }
  def on_keyword_rest_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#351
  sig { params(node: ::Prism::LocalVariableAndWriteNode).void }
  def on_local_variable_and_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#358
  sig { params(node: ::Prism::LocalVariableOperatorWriteNode).void }
  def on_local_variable_operator_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#365
  sig { params(node: ::Prism::LocalVariableOrWriteNode).void }
  def on_local_variable_or_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#338
  sig { params(node: ::Prism::LocalVariableReadNode).void }
  def on_local_variable_read_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#372
  sig { params(node: ::Prism::LocalVariableTargetNode).void }
  def on_local_variable_target_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#331
  sig { params(node: ::Prism::LocalVariableWriteNode).void }
  def on_local_variable_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#173
  sig { params(node: ::Prism::MatchWriteNode).void }
  def on_match_write_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#183
  sig { params(node: ::Prism::MatchWriteNode).void }
  def on_match_write_node_leave(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#395
  sig { params(node: ::Prism::ModuleNode).void }
  def on_module_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#277
  sig { params(node: ::Prism::OptionalKeywordParameterNode).void }
  def on_optional_keyword_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#297
  sig { params(node: ::Prism::OptionalParameterNode).void }
  def on_optional_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#268
  sig { params(node: ::Prism::RequiredKeywordParameterNode).void }
  def on_required_keyword_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#305
  sig { params(node: ::Prism::RequiredParameterNode).void }
  def on_required_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#313
  sig { params(node: ::Prism::RestParameterNode).void }
  def on_rest_parameter_node_enter(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#324
  sig { params(node: ::Prism::SelfNode).void }
  def on_self_node_enter(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#404
  sig { params(location: ::Prism::Location, type: ::Symbol, modifiers: T::Array[::Symbol]).void }
  def add_token(location, type, modifiers = T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#425
  sig { params(node: ::Prism::CallNode).void }
  def process_regexp_locals(node); end

  # Textmate provides highlighting for a subset of these special Ruby-specific methods.  We want to utilize that
  # highlighting, so we avoid making a semantic token for it.
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#420
  sig { params(method_name: ::String).returns(T::Boolean) }
  def special_method?(method_name); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#72
RubyLsp::Requests::SemanticHighlighting::SPECIAL_RUBY_METHODS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#83
class RubyLsp::Requests::SemanticHighlighting::SemanticToken
  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#99
  sig { params(location: ::Prism::Location, length: ::Integer, type: ::Integer, modifier: T::Array[::Integer]).void }
  def initialize(location:, length:, type:, modifier:); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#90
  sig { returns(::Integer) }
  def length; end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#87
  sig { returns(::Prism::Location) }
  def location; end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#96
  sig { returns(T::Array[::Integer]) }
  def modifier; end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#93
  sig { returns(::Integer) }
  def type; end
end

# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#56
RubyLsp::Requests::SemanticHighlighting::TOKEN_MODIFIERS = T.let(T.unsafe(nil), Hash)

# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#27
RubyLsp::Requests::SemanticHighlighting::TOKEN_TYPES = T.let(T.unsafe(nil), Hash)

# ![Show syntax tree demo](../../show_syntax_tree.gif)
#
# Show syntax tree is a custom [LSP
# request](https://microsoft.github.io/language-server-protocol/specification#requestMessage) that displays the AST
# for the current document or for the current selection in a new tab.
#
# # Example
#
# ```ruby
# # Executing the Ruby LSP: Show syntax tree command will display the AST for the document
# 1 + 1
# # (program (statements ((binary (int "1") + (int "1")))))
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/show_syntax_tree.rb#20
class RubyLsp::Requests::ShowSyntaxTree < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/show_syntax_tree.rb#24
  sig do
    params(
      document: ::RubyLsp::Document,
      range: T.nilable({start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}})
    ).void
  end
  def initialize(document, range); end

  # source://ruby-lsp/lib/ruby_lsp/requests/show_syntax_tree.rb#31
  sig { override.returns(::String) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/show_syntax_tree.rb#42
  sig { returns(::String) }
  def ast_for_range; end
end

# source://ruby-lsp/lib/ruby_lsp/requests.rb#48
module RubyLsp::Requests::Support; end

# source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#7
class RubyLsp::Requests::Support::Annotation
  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#15
  sig { params(arity: T.any(::Integer, T::Range[::Integer]), receiver: T::Boolean).void }
  def initialize(arity:, receiver: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#21
  sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
  def match?(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#34
  sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
  def arity_matches?(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#28
  sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
  def receiver_matches?(node); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#7
module RubyLsp::Requests::Support::Common
  requires_ancestor { Kernel }

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#58
  sig do
    params(
      node: ::Prism::Node,
      title: ::String,
      command_name: ::String,
      arguments: T.nilable(T::Array[T.untyped]),
      data: T.nilable(T::Hash[T.untyped, T.untyped])
    ).returns(::LanguageServer::Protocol::Interface::CodeLens)
  end
  def create_code_lens(node, title:, command_name:, arguments:, data:); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#73
  sig { params(file_path: ::String).returns(T.nilable(T::Boolean)) }
  def defined_in_gem?(file_path); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#90
  sig do
    params(
      title: ::String,
      entries: T.any(::RubyIndexer::Entry, T::Array[::RubyIndexer::Entry])
    ).returns(::LanguageServer::Protocol::Interface::MarkupContent)
  end
  def markdown_from_index_entries(title, entries); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#30
  sig { params(location: ::Prism::Location).returns(::LanguageServer::Protocol::Interface::Range) }
  def range_from_location(location); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#17
  sig { params(node: ::Prism::Node).returns(::LanguageServer::Protocol::Interface::Range) }
  def range_from_node(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#79
  sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
  def self_receiver?(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#41
  sig { params(node: T.nilable(::Prism::Node), range: T.nilable(T::Range[::Integer])).returns(T::Boolean) }
  def visible?(node, range); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/requests/support/formatter_runner.rb#7
module RubyLsp::Requests::Support::FormatterRunner
  interface!

  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/support/formatter_runner.rb#14
  sig { abstract.params(uri: ::URI::Generic, document: ::RubyLsp::Document).returns(T.nilable(::String)) }
  def run(uri, document); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#19
class RubyLsp::Requests::Support::InternalRuboCopError < ::StandardError
  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#29
  sig { params(rubocop_error: T.any(::RuboCop::ErrorWithAnalyzedFileLocation, ::StandardError)).void }
  def initialize(rubocop_error); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#22
RubyLsp::Requests::Support::InternalRuboCopError::MESSAGE = T.let(T.unsafe(nil), String)

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#7
class RubyLsp::Requests::Support::RuboCopDiagnostic
  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#23
  sig { params(offense: ::RuboCop::Cop::Offense, uri: ::URI::Generic).void }
  def initialize(offense, uri); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#29
  sig { returns(::LanguageServer::Protocol::Interface::CodeAction) }
  def to_lsp_code_action; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#49
  sig { returns(::LanguageServer::Protocol::Interface::Diagnostic) }
  def to_lsp_diagnostic; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#88
  sig { returns(T.nilable(::LanguageServer::Protocol::Interface::CodeDescription)) }
  def code_description; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#76
  sig { returns(::String) }
  def message; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#94
  sig { returns(T::Array[::LanguageServer::Protocol::Interface::TextEdit]) }
  def offense_replacements; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#83
  sig { returns(T.nilable(::Integer)) }
  def severity; end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#10
RubyLsp::Requests::Support::RuboCopDiagnostic::RUBOCOP_TO_LSP_SEVERITY = T.let(T.unsafe(nil), Hash)

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostics_runner.rb#12
class RubyLsp::Requests::Support::RuboCopDiagnosticsRunner
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostics_runner.rb#17
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostics_runner.rb#22
  sig do
    params(
      uri: ::URI::Generic,
      document: ::RubyLsp::Document
    ).returns(T::Array[::RubyLsp::Requests::Support::RuboCopDiagnostic])
  end
  def run(uri, document); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_formatting_runner.rb#12
class RubyLsp::Requests::Support::RuboCopFormattingRunner
  include ::Singleton
  include ::RubyLsp::Requests::Support::FormatterRunner
  extend ::Singleton::SingletonClassMethods

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_formatting_runner.rb#18
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_formatting_runner.rb#24
  sig { override.params(uri: ::URI::Generic, document: ::RubyLsp::Document).returns(::String) }
  def run(uri, document); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#41
class RubyLsp::Requests::Support::RuboCopRunner < ::RuboCop::Runner
  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#68
  sig { params(args: ::String).void }
  def initialize(*args); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#100
  sig { returns(::String) }
  def formatted_source; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#47
  sig { returns(T::Array[::RuboCop::Cop::Offense]) }
  def offenses; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#82
  sig { params(path: ::String, contents: ::String).void }
  def run(path, contents); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#126
  sig { params(_file: ::String, offenses: T::Array[::RuboCop::Cop::Offense]).void }
  def file_finished(_file, offenses); end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#108
    sig { params(cop_name: ::String).returns(T.nilable(T.class_of(RuboCop::Cop::Base))) }
    def find_cop_by_name(cop_name); end

    private

    # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#115
    sig { returns(T::Hash[::String, [T.class_of(RuboCop::Cop::Base)]]) }
    def cop_registry; end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#44
class RubyLsp::Requests::Support::RuboCopRunner::ConfigurationError < ::StandardError; end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#49
RubyLsp::Requests::Support::RuboCopRunner::DEFAULT_ARGS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/support/selection_range.rb#7
class RubyLsp::Requests::Support::SelectionRange < ::LanguageServer::Protocol::Interface::SelectionRange
  # source://ruby-lsp/lib/ruby_lsp/requests/support/selection_range.rb#11
  sig { params(position: {line: ::Integer, character: ::Integer}).returns(T::Boolean) }
  def cover?(position); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#7
class RubyLsp::Requests::Support::SemanticTokenEncoder
  # source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#11
  sig { void }
  def initialize; end

  # For more information on how each number is calculated, read:
  # https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_semanticTokens
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#43
  sig { params(token: ::RubyLsp::Requests::SemanticHighlighting::SemanticToken).returns(T::Array[::Integer]) }
  def compute_delta(token); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#21
  sig do
    params(
      tokens: T::Array[::RubyLsp::Requests::SemanticHighlighting::SemanticToken]
    ).returns(::LanguageServer::Protocol::Interface::SemanticTokens)
  end
  def encode(tokens); end

  # Encode an array of modifiers to positions onto a bit flag
  # For example, [:default_library] will be encoded as
  # 0b1000000000, as :default_library is the 10th bit according
  # to the token modifiers index map.
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#65
  sig { params(modifiers: T::Array[::Integer]).returns(::Integer) }
  def encode_modifiers(modifiers); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/sorbet.rb#7
class RubyLsp::Requests::Support::Sorbet
  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/support/sorbet.rb#48
    sig { params(node: ::Prism::CallNode).returns(T::Boolean) }
    def annotation?(node); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/syntax_tree_formatting_runner.rb#17
class RubyLsp::Requests::Support::SyntaxTreeFormattingRunner
  include ::Singleton
  include ::RubyLsp::Requests::Support::FormatterRunner
  extend ::Singleton::SingletonClassMethods

  # source://ruby-lsp/lib/ruby_lsp/requests/support/syntax_tree_formatting_runner.rb#23
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/syntax_tree_formatting_runner.rb#36
  sig { override.params(uri: ::URI::Generic, document: ::RubyLsp::Document).returns(T.nilable(::String)) }
  def run(uri, document); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# ![Workspace symbol demo](../../workspace_symbol.gif)
#
# The [workspace symbol](https://microsoft.github.io/language-server-protocol/specification#workspace_symbol)
# request allows fuzzy searching declarations in the entire project. On VS Code, use CTRL/CMD + T to search for
# symbols.
#
# # Example
#
# ```ruby
# # Searching for `Floo` will fuzzy match and return all declarations according to the query, including this `Foo`
# class
# class Foo
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/workspace_symbol.rb#21
class RubyLsp::Requests::WorkspaceSymbol
  include ::RubyLsp::Requests::Support::Common

  # source://ruby-lsp/lib/ruby_lsp/requests/workspace_symbol.rb#26
  sig { params(query: T.nilable(::String), index: ::RubyIndexer::Index).void }
  def initialize(query, index); end

  # source://ruby-lsp/lib/ruby_lsp/requests/workspace_symbol.rb#32
  sig { returns(T::Array[::LanguageServer::Protocol::Interface::WorkspaceSymbol]) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/workspace_symbol.rb#68
  sig { params(entry: ::RubyIndexer::Entry).returns(T.nilable(::Integer)) }
  def kind_for_entry(entry); end
end

# The final result of running a request before its IO is finalized
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#40
class RubyLsp::Result
  # source://ruby-lsp/lib/ruby_lsp/utils.rb#50
  sig { params(response: T.untyped, error: T.nilable(::Exception)).void }
  def initialize(response:, error: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#47
  sig { returns(T.nilable(::Exception)) }
  def error; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#44
  sig { returns(T.untyped) }
  def response; end
end

# source://ruby-lsp/lib/ruby_lsp/ruby_document.rb#5
class RubyLsp::RubyDocument < ::RubyLsp::Document
  # source://ruby-lsp/lib/ruby_lsp/ruby_document.rb#7
  sig { override.returns(::Prism::ParseResult) }
  def parse; end
end

# source://ruby-lsp/lib/ruby_lsp/server.rb#11
class RubyLsp::Server
  # source://ruby-lsp/lib/ruby_lsp/server.rb#15
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/server.rb#60
  sig { void }
  def start; end

  private

  # Finalize a Queue::Result. All IO operations should happen here to avoid any issues with cancelling requests
  #
  # source://ruby-lsp/lib/ruby_lsp/server.rb#145
  sig { params(result: ::RubyLsp::Result, request: T::Hash[::Symbol, T.untyped]).void }
  def finalize_request(result, request); end

  # source://ruby-lsp/lib/ruby_lsp/server.rb#120
  sig { returns(::Thread) }
  def new_worker; end
end

# source://ruby-lsp/lib/ruby_lsp/store.rb#5
class RubyLsp::Store
  # source://ruby-lsp/lib/ruby_lsp/store.rb#24
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#77
  sig do
    type_parameters(:T)
      .params(
        uri: ::URI::Generic,
        request_name: ::String,
        block: T.proc.params(document: ::RubyLsp::Document).returns(T.type_parameter(:T))
      ).returns(T.type_parameter(:T))
  end
  def cache_fetch(uri, request_name, &block); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#55
  sig { void }
  def clear; end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#65
  sig { params(uri: ::URI::Generic).void }
  def delete(uri); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#60
  sig { returns(T::Boolean) }
  def empty?; end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#9
  sig { returns(::String) }
  def encoding; end

  # @return [String]
  #
  # source://ruby-lsp/lib/ruby_lsp/store.rb#9
  def encoding=(_arg0); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#18
  sig { returns(T::Boolean) }
  def experimental_features; end

  # @return [Boolean]
  #
  # source://ruby-lsp/lib/ruby_lsp/store.rb#18
  def experimental_features=(_arg0); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#12
  sig { returns(::String) }
  def formatter; end

  # @return [String]
  #
  # source://ruby-lsp/lib/ruby_lsp/store.rb#12
  def formatter=(_arg0); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#34
  sig { params(uri: ::URI::Generic).returns(::RubyLsp::Document) }
  def get(uri); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#50
  sig do
    params(
      uri: ::URI::Generic,
      edits: T::Array[{range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}, text: ::String}],
      version: ::Integer
    ).void
  end
  def push_edits(uri:, edits:, version:); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#44
  sig { params(uri: ::URI::Generic, source: ::String, version: ::Integer).void }
  def set(uri:, source:, version:); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#15
  sig { returns(T::Boolean) }
  def supports_progress; end

  # @return [Boolean]
  #
  # source://ruby-lsp/lib/ruby_lsp/store.rb#15
  def supports_progress=(_arg0); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#21
  sig { returns(::URI::Generic) }
  def workspace_uri; end

  # @return [URI::Generic]
  #
  # source://ruby-lsp/lib/ruby_lsp/store.rb#21
  def workspace_uri=(_arg0); end
end

# source://ruby-lsp/lib/ruby_lsp/server.rb#8
RubyLsp::Transport = LanguageServer::Protocol::Transport

# source://ruby-lsp/lib/ruby-lsp.rb#5
RubyLsp::VERSION = T.let(T.unsafe(nil), String)

# Used to indicate that a request shouldn't return a response
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#6
RubyLsp::VOID = T.let(T.unsafe(nil), Object)

# source://ruby-lsp/lib/core_ext/uri.rb#4
module URI
  include ::URI::RFC2396_REGEXP
end

# source://ruby-lsp/lib/core_ext/uri.rb#5
class URI::Generic
  include ::URI::RFC2396_REGEXP
  include ::URI
end

# Must be kept in sync with the one in Tapioca
#
# source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#8
class URI::Source < ::URI::File
  # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#62
  sig { params(v: T.nilable(::String)).returns(T::Boolean) }
  def check_host(v); end

  # source://uri/0.12.1uri/generic.rb#243
  def gem_name; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#26
  sig { returns(T.nilable(::String)) }
  def gem_version; end

  # source://uri/0.12.1uri/generic.rb#283
  def line_number; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#52
  sig { params(v: T.nilable(::String)).void }
  def set_path(v); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#74
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#39
    sig do
      params(
        gem_name: ::String,
        gem_version: T.nilable(::String),
        path: ::String,
        line_number: T.nilable(::String)
      ).returns(::URI::Source)
    end
    def build(gem_name:, gem_version:, path:, line_number:); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#11
URI::Source::COMPONENT = T.let(T.unsafe(nil), Array)

class URI::WSS < ::URI::WS; end
