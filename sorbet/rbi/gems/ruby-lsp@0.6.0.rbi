# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ruby-lsp` gem.
# Please instead update this file by running `bin/tapioca gem ruby-lsp`.

# source://ruby-lsp/lib/ruby-lsp.rb#4
module RubyLsp; end

# source://ruby-lsp/lib/ruby_lsp/server.rb#7
RubyLsp::Constant = LanguageServer::Protocol::Constant

# source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#5
module RubyLsp::DependencyDetector
  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#10
    sig { returns(::String) }
    def detected_formatter; end

    # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#22
    sig { returns(::String) }
    def detected_test_library; end

    # source://ruby-lsp/lib/ruby_lsp/requests/support/dependency_detector.rb#36
    sig { params(gem_pattern: ::Regexp).returns(T::Boolean) }
    def direct_dependency?(gem_pattern); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/document.rb#5
class RubyLsp::Document
  # source://ruby-lsp/lib/ruby_lsp/document.rb#25
  sig { params(source: ::String, version: ::Integer, uri: ::String, encoding: ::String).void }
  def initialize(source:, version:, uri:, encoding: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#39
  sig { params(other: ::RubyLsp::Document).returns(T::Boolean) }
  def ==(other); end

  # TODO: remove this method once all nonpositional requests have been migrated to the listener pattern
  #
  # source://ruby-lsp/lib/ruby_lsp/document.rb#51
  sig do
    type_parameters(:T)
      .params(
        request_name: ::String,
        block: T.proc.params(document: ::RubyLsp::Document).returns(T.type_parameter(:T))
      ).returns(T.type_parameter(:T))
  end
  def cache_fetch(request_name, &block); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#66
  sig { params(request_name: ::String).returns(T.untyped) }
  def cache_get(request_name); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#61
  sig { type_parameters(:T).params(request_name: ::String, value: T.type_parameter(:T)).returns(T.type_parameter(:T)) }
  def cache_set(request_name, value); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#109
  sig { returns(::RubyLsp::Document::Scanner) }
  def create_scanner; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#132
  sig do
    params(
      node: ::SyntaxTree::Node,
      char_position: ::Integer,
      node_types: T::Array[T.class_of(SyntaxTree::Node)]
    ).returns([T.nilable(::SyntaxTree::Node), T.nilable(::SyntaxTree::Node)])
  end
  def locate(node, char_position, node_types: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#119
  sig do
    params(
      position: {line: ::Integer, character: ::Integer},
      node_types: T::Array[T.class_of(SyntaxTree::Node)]
    ).returns([T.nilable(::SyntaxTree::Node), T.nilable(::SyntaxTree::Node)])
  end
  def locate_node(position, node_types: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#88
  sig { void }
  def parse; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#104
  sig { returns(T::Boolean) }
  def parsed?; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#71
  sig do
    params(
      edits: T::Array[{range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}, text: ::String}],
      version: ::Integer
    ).void
  end
  def push_edits(edits, version:); end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#16
  sig { returns(::String) }
  def source; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#99
  sig { returns(T::Boolean) }
  def syntax_error?; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#13
  sig { returns(T.nilable(::SyntaxTree::Node)) }
  def tree; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#22
  sig { returns(::String) }
  def uri; end

  # source://ruby-lsp/lib/ruby_lsp/document.rb#19
  sig { returns(::Integer) }
  def version; end
end

# source://ruby-lsp/lib/ruby_lsp/document.rb#10
RubyLsp::Document::EditShape = T.type_alias { {range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}, text: ::String} }

# source://ruby-lsp/lib/ruby_lsp/document.rb#8
RubyLsp::Document::PositionShape = T.type_alias { {line: ::Integer, character: ::Integer} }

# source://ruby-lsp/lib/ruby_lsp/document.rb#9
RubyLsp::Document::RangeShape = T.type_alias { {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}} }

# source://ruby-lsp/lib/ruby_lsp/document.rb#168
class RubyLsp::Document::Scanner
  # source://ruby-lsp/lib/ruby_lsp/document.rb#176
  sig { params(source: ::String, encoding: ::String).void }
  def initialize(source, encoding); end

  # Finds the character index inside the source string for a given line and column
  #
  # source://ruby-lsp/lib/ruby_lsp/document.rb#185
  sig { params(position: {line: ::Integer, character: ::Integer}).returns(::Integer) }
  def find_char_position(position); end

  # Subtract 1 for each character after 0xFFFF in the current line from the column position, so that we hit the
  # right character in the UTF-8 representation
  #
  # source://ruby-lsp/lib/ruby_lsp/document.rb#207
  sig { params(current_position: ::Integer, requested_position: ::Integer).returns(::Integer) }
  def utf_16_character_position_correction(current_position, requested_position); end
end

# source://ruby-lsp/lib/ruby_lsp/document.rb#171
RubyLsp::Document::Scanner::LINE_BREAK = T.let(T.unsafe(nil), Integer)

# After character 0xFFFF, UTF-16 considers characters to have length 2 and we have to account for that
#
# source://ruby-lsp/lib/ruby_lsp/document.rb#173
RubyLsp::Document::Scanner::SURROGATE_PAIR_START = T.let(T.unsafe(nil), Integer)

# EventEmitter is an intermediary between our requests and Syntax Tree visitors. It's used to visit the document's AST
# and emit events that the requests can listen to for providing functionality. Usages:
#
# - For positional requests, locate the target node and use `emit_for_target` to fire events for each listener
# - For nonpositional requests, use `visit` to go through the AST, which will fire events for each listener as nodes
# are found
#
# # Example
#
# ```ruby
# target_node = document.locate_node(position)
# emitter = EventEmitter.new
# listener = Requests::Hover.new(emitter, @message_queue)
# emitter.emit_for_target(target_node)
# listener.response
# ```
#
# source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#21
class RubyLsp::EventEmitter < ::SyntaxTree::Visitor
  include ::SyntaxTree::WithScope

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#26
  sig { void }
  def initialize; end

  # Emit events for a specific node. This is similar to the regular `visit` method, but avoids going deeper into the
  # tree for performance
  #
  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#39
  sig { params(node: T.nilable(::SyntaxTree::Node)).void }
  def emit_for_target(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#32
  sig { params(listener: RubyLsp::Listener[T.untyped], events: ::Symbol).void }
  def register(listener, *events); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#170
  sig { override.params(node: ::SyntaxTree::Binary).void }
  def visit_binary(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#158
  sig { override.params(node: ::SyntaxTree::BlockVar).void }
  def visit_block_var(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#84
  sig { override.params(node: ::SyntaxTree::CallNode).void }
  def visit_call(node); end

  # Visit dispatchers are below. Notice that for nodes that create a new scope (e.g.: classes, modules, method defs)
  # we need both an `on_*` and `after_*` event. This is because some requests must know when we exit the scope
  #
  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#57
  sig { override.params(node: ::SyntaxTree::ClassDeclaration).void }
  def visit_class(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#71
  sig { override.params(node: ::SyntaxTree::Command).void }
  def visit_command(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#78
  sig { override.params(node: ::SyntaxTree::CommandCall).void }
  def visit_command_call(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#122
  sig { override.params(node: ::SyntaxTree::Comment).void }
  def visit_comment(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#176
  sig { override.params(node: ::SyntaxTree::Const).void }
  def visit_const(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#97
  sig { override.params(node: ::SyntaxTree::ConstPathField).void }
  def visit_const_path_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#109
  sig { override.params(node: ::SyntaxTree::DefNode).void }
  def visit_def(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#146
  sig { override.params(node: ::SyntaxTree::Field).void }
  def visit_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#134
  sig { override.params(node: ::SyntaxTree::Kw).void }
  def visit_kw(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#164
  sig { override.params(node: ::SyntaxTree::LambdaVar).void }
  def visit_lambda_var(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#64
  sig { override.params(node: ::SyntaxTree::ModuleDeclaration).void }
  def visit_module(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#140
  sig { override.params(node: ::SyntaxTree::Params).void }
  def visit_params(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#128
  sig { override.params(node: ::SyntaxTree::Rescue).void }
  def visit_rescue(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#103
  sig { override.params(node: ::SyntaxTree::TopConstField).void }
  def visit_top_const_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#116
  sig { override.params(node: ::SyntaxTree::VarField).void }
  def visit_var_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#152
  sig { override.params(node: ::SyntaxTree::VarRef).void }
  def visit_var_ref(node); end

  # source://ruby-lsp/lib/ruby_lsp/event_emitter.rb#91
  sig { override.params(node: ::SyntaxTree::VCall).void }
  def visit_vcall(node); end
end

# This class dispatches a request execution to the right request class. No IO should happen anywhere here!
#
# source://ruby-lsp/lib/ruby_lsp/executor.rb#8
class RubyLsp::Executor
  # source://ruby-lsp/lib/ruby_lsp/executor.rb#12
  sig { params(store: ::RubyLsp::Store, message_queue: ::Thread::Queue).void }
  def initialize(store, message_queue); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#21
  sig { params(request: T::Hash[::Symbol, T.untyped]).returns(::RubyLsp::Result) }
  def execute(request); end

  private

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#540
  sig { void }
  def check_formatter_is_available; end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#305
  sig do
    params(
      uri: ::String,
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}},
      context: T::Hash[::Symbol, T.untyped]
    ).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::CodeAction]))
  end
  def code_action(uri, range, context); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#312
  sig { params(params: T::Hash[::Symbol, T.untyped]).returns(::LanguageServer::Protocol::Interface::CodeAction) }
  def code_action_resolve(params); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#370
  sig do
    params(
      uri: ::String,
      position: {line: ::Integer, character: ::Integer}
    ).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::CompletionItem]))
  end
  def completion(uri, position); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#342
  sig { params(uri: ::String).returns(T.nilable(::LanguageServer::Protocol::Interface::FullDocumentDiagnosticReport)) }
  def diagnostic(uri); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#280
  sig do
    params(
      uri: ::String,
      position: {line: ::Integer, character: ::Integer}
    ).returns(T::Array[::LanguageServer::Protocol::Interface::DocumentHighlight])
  end
  def document_highlight(uri, position); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#176
  sig { params(uri: ::String).returns(T::Array[::LanguageServer::Protocol::Interface::FoldingRange]) }
  def folding_range(uri); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#256
  sig { params(uri: ::String).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::TextEdit])) }
  def formatting(uri); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#188
  sig do
    params(
      uri: ::String,
      position: {line: ::Integer, character: ::Integer}
    ).returns(T.nilable(::LanguageServer::Protocol::Interface::Hover))
  end
  def hover(uri, position); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#412
  sig do
    params(
      options: T::Hash[::Symbol, T.untyped]
    ).returns(::LanguageServer::Protocol::Interface::InitializeResult)
  end
  def initialize_request(options); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#285
  sig do
    params(
      uri: ::String,
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}
    ).returns(T.nilable(T::Array[::LanguageServer::Protocol::Interface::InlayHint]))
  end
  def inlay_hint(uri, range); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#270
  sig do
    params(
      uri: ::String,
      position: {line: ::Integer, character: ::Integer},
      character: ::String
    ).returns(T::Array[::LanguageServer::Protocol::Interface::TextEdit])
  end
  def on_type_formatting(uri, position, character); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#37
  sig { params(request: T::Hash[::Symbol, T.untyped]).returns(T.untyped) }
  def run(request); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#236
  sig do
    params(
      uri: ::String,
      positions: T::Array[{line: ::Integer, character: ::Integer}]
    ).returns(T.nilable(T::Array[T.nilable(::RubyLsp::Requests::Support::SelectionRange)]))
  end
  def selection_range(uri, positions); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#351
  sig do
    params(
      uri: ::String,
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}
    ).returns(::LanguageServer::Protocol::Interface::SemanticTokens)
  end
  def semantic_tokens_range(uri, range); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#213
  sig do
    params(
      uri: ::String,
      content_changes: T::Array[{range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}, text: ::String}],
      version: ::Integer
    ).returns(::Object)
  end
  def text_document_did_change(uri, content_changes, version); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#225
  sig { params(uri: ::String).returns(::Object) }
  def text_document_did_close(uri); end

  # source://ruby-lsp/lib/ruby_lsp/executor.rb#219
  sig { params(uri: ::String, text: ::String, version: ::Integer).returns(::Object) }
  def text_document_did_open(uri, text, version); end
end

# To register an extension, inherit from this class and implement both `name` and `activate`
#
# # Example
#
# ```ruby
# module MyGem
#   class MyExtension < Extension
#     def activate
#       # Perform any relevant initialization
#     end
#
#     def name
#       "My extension name"
#     end
#   end
# end
# ```
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/extension.rb#22
class RubyLsp::Extension
  abstract!

  # source://ruby-lsp/lib/ruby_lsp/extension.rb#67
  sig { void }
  def initialize; end

  # Each extension should implement `MyExtension#activate` and use to perform any sort of initialization, such as
  # reading information into memory or even spawning a separate process
  #
  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/extension.rb#98
  sig { abstract.void }
  def activate; end

  # source://ruby-lsp/lib/ruby_lsp/extension.rb#72
  sig { params(error: ::StandardError).returns(T.self_type) }
  def add_error(error); end

  # source://ruby-lsp/lib/ruby_lsp/extension.rb#91
  sig { returns(::String) }
  def backtraces; end

  # source://ruby-lsp/lib/ruby_lsp/extension.rb#78
  sig { returns(T::Boolean) }
  def error?; end

  # source://ruby-lsp/lib/ruby_lsp/extension.rb#83
  sig { returns(::String) }
  def formatted_errors; end

  # Extensions should override the `name` method to return the extension name
  #
  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/extension.rb#102
  sig { abstract.returns(::String) }
  def name; end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/extension.rb#39
    sig { returns(T::Array[::RubyLsp::Extension]) }
    def extensions; end

    # Automatically track and instantiate extension classes
    #
    # source://ruby-lsp/lib/ruby_lsp/extension.rb#33
    sig { params(child_class: T.class_of(RubyLsp::Extension)).void }
    def inherited(child_class); end

    # Discovers and loads all extensions. Returns the list of activated extensions
    #
    # source://ruby-lsp/lib/ruby_lsp/extension.rb#45
    sig { returns(T::Array[::RubyLsp::Extension]) }
    def load_extensions; end

    # source://sorbet-runtime/0.5.10838lib/types/private/abstract/declare.rb#37
    def new(*args, **_arg1, &blk); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/server.rb#6
RubyLsp::Interface = LanguageServer::Protocol::Interface

# A request that will sit in the queue until it's executed
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#62
class RubyLsp::Job
  # source://ruby-lsp/lib/ruby_lsp/utils.rb#72
  sig { params(request: T::Hash[::Symbol, T.untyped], cancelled: T::Boolean).void }
  def initialize(request:, cancelled:); end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#78
  sig { void }
  def cancel; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#69
  sig { returns(T::Boolean) }
  def cancelled; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#66
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def request; end
end

# Listener is an abstract class to be used by requests for listening to events emitted when visiting an AST using the
# EventEmitter.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/listener.rb#7
class RubyLsp::Listener
  extend T::Generic
  include ::RubyLsp::Requests::Support::Common

  abstract!

  ResponseType = type_member

  # source://ruby-lsp/lib/ruby_lsp/listener.rb#18
  sig { params(emitter: ::RubyLsp::EventEmitter, message_queue: ::Thread::Queue).void }
  def initialize(emitter, message_queue); end

  # Override this method with an attr_reader that returns the response of your listener. The listener should
  # accumulate results in a @response variable and then provide the reader so that it is accessible
  #
  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/listener.rb#40
  sig { abstract.returns(ResponseType) }
  def response; end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/listener.rb#32
    sig { params(listener: T.class_of(RubyLsp::Listener)).void }
    def add_listener(listener); end

    # source://ruby-lsp/lib/ruby_lsp/listener.rb#27
    sig { returns(T::Array[T.class_of(RubyLsp::Listener)]) }
    def listeners; end

    # source://sorbet-runtime/0.5.10838lib/types/private/abstract/declare.rb#37
    def new(*args, **_arg1, &blk); end
  end
end

# A notification to be sent to the client
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#12
class RubyLsp::Message
  abstract!

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#25
  sig { params(message: ::String, params: ::Object).void }
  def initialize(message:, params:); end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#19
  sig { returns(::String) }
  def message; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#22
  sig { returns(::Object) }
  def params; end

  class << self
    # source://sorbet-runtime/0.5.10838lib/types/private/abstract/declare.rb#37
    def new(*args, **_arg1, &blk); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/utils.rb#31
class RubyLsp::Notification < ::RubyLsp::Message; end

# source://ruby-lsp/lib/ruby_lsp/utils.rb#32
class RubyLsp::Request < ::RubyLsp::Message; end

# Supported features
#
# - [DocumentSymbol](rdoc-ref:RubyLsp::Requests::DocumentSymbol)
# - [DocumentLink](rdoc-ref:RubyLsp::Requests::DocumentLink)
# - [Hover](rdoc-ref:RubyLsp::Requests::Hover)
# - [FoldingRange](rdoc-ref:RubyLsp::Requests::FoldingRanges)
# - [SelectionRange](rdoc-ref:RubyLsp::Requests::SelectionRanges)
# - [SemanticHighlighting](rdoc-ref:RubyLsp::Requests::SemanticHighlighting)
# - [Formatting](rdoc-ref:RubyLsp::Requests::Formatting)
# - [OnTypeFormatting](rdoc-ref:RubyLsp::Requests::OnTypeFormatting)
# - [Diagnostic](rdoc-ref:RubyLsp::Requests::Diagnostics)
# - [CodeAction](rdoc-ref:RubyLsp::Requests::CodeActions)
# - [CodeActionResolve](rdoc-ref:RubyLsp::Requests::CodeActionResolve)
# - [DocumentHighlight](rdoc-ref:RubyLsp::Requests::DocumentHighlight)
# - [InlayHint](rdoc-ref:RubyLsp::Requests::InlayHints)
# - [PathCompletion](rdoc-ref:RubyLsp::Requests::PathCompletion)
# - [CodeLens](rdoc-ref:RubyLsp::Requests::CodeLens)
#
# source://ruby-lsp/lib/ruby_lsp/requests.rb#23
module RubyLsp::Requests; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/requests/base_request.rb#7
class RubyLsp::Requests::BaseRequest < ::SyntaxTree::Visitor
  include ::RubyLsp::Requests::Support::Common

  abstract!

  # source://ruby-lsp/lib/ruby_lsp/requests/base_request.rb#15
  sig { params(document: ::RubyLsp::Document).void }
  def initialize(document); end

  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/base_request.rb#21
  sig { abstract.returns(::Object) }
  def run; end

  # Syntax Tree implements `visit_all` using `map` instead of `each` for users who want to use the pattern
  # `result = visitor.visit(tree)`. However, we don't use that pattern and should avoid producing a new array for
  # every single node visited
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/base_request.rb#27
  sig { params(nodes: T::Array[T.nilable(::SyntaxTree::Node)]).void }
  def visit_all(nodes); end

  class << self
    # source://sorbet-runtime/0.5.10838lib/types/private/abstract/declare.rb#37
    def new(*args, **_arg1, &blk); end
  end
end

# ![Code action resolve demo](../../code_action_resolve.gif)
#
# The [code action resolve](https://microsoft.github.io/language-server-protocol/specification#codeAction_resolve)
# request is used to to resolve the edit field for a given code action, if it is not already provided in the
# textDocument/codeAction response. We can use it for scenarios that require more computation such as refactoring.
#
# # Example: Extract to variable
#
# ```ruby
# # Before:
# 1 + 1 # Select the text and use Refactor: Extract Variable
#
# # After:
# new_variable = 1 + 1
# new_variable
#
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#24
class RubyLsp::Requests::CodeActionResolve < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#38
  sig { params(document: ::RubyLsp::Document, code_action: T::Hash[::Symbol, T.untyped]).void }
  def initialize(document, code_action); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#45
  sig do
    override
      .returns(T.any(::LanguageServer::Protocol::Interface::CodeAction, ::RubyLsp::Requests::CodeActionResolve::Error))
  end
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#137
  sig do
    params(
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}},
      new_text: ::String
    ).returns(::LanguageServer::Protocol::Interface::TextEdit)
  end
  def create_text_edit(range, new_text); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#28
class RubyLsp::Requests::CodeActionResolve::CodeActionError < ::StandardError; end

# source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#30
class RubyLsp::Requests::CodeActionResolve::Error < ::T::Enum
  enums do
    EmptySelection = new
    InvalidTargetRange = new
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/code_action_resolve.rb#26
RubyLsp::Requests::CodeActionResolve::NEW_VARIABLE_NAME = T.let(T.unsafe(nil), String)

# ![Code actions demo](../../code_actions.gif)
#
# The [code actions](https://microsoft.github.io/language-server-protocol/specification#textDocument_codeAction)
# request informs the editor of RuboCop quick fixes that can be applied. These are accessible by hovering over a
# specific diagnostic.
#
# # Example
#
# ```ruby
# def say_hello
# puts "Hello" # --> code action: quick fix indentation
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#19
class RubyLsp::Requests::CodeActions < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#29
  sig do
    params(
      document: ::RubyLsp::Document,
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}},
      context: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(document, range, context); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#38
  sig { override.returns(T.nilable(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::CodeAction]))) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#59
  sig do
    params(
      range: T.nilable({start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}})
    ).returns(T::Boolean)
  end
  def cover?(range); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_actions.rb#67
  sig do
    params(
      range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}},
      uri: ::String
    ).returns(::LanguageServer::Protocol::Interface::CodeAction)
  end
  def refactor_code_action(range, uri); end
end

# ![Code lens demo](../../code_lens.gif)
#
# This feature is currently experimental. Clients will need to pass `experimentalFeaturesEnabled`
# in the initialization options to enable it.
#
# The
# [code lens](https://microsoft.github.io/language-server-protocol/specification#textDocument_codeLens)
# request informs the editor of runnable commands such as tests
#
# # Example
#
# ```ruby
# # Run
# class Test < Minitest::Test
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#24
class RubyLsp::Requests::CodeLens < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::CodeLens] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#37
  sig do
    params(
      uri: ::String,
      emitter: ::RubyLsp::EventEmitter,
      message_queue: ::Thread::Queue,
      test_library: ::String
    ).void
  end
  def initialize(uri, emitter, message_queue, test_library); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#132
  sig { params(node: ::SyntaxTree::CallNode).void }
  def after_call(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#76
  sig { params(node: ::SyntaxTree::ClassDeclaration).void }
  def after_class(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#113
  sig { params(node: ::SyntaxTree::Command).void }
  def after_command(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#148
  sig { params(other: RubyLsp::Listener[ResponseType]).returns(T.self_type) }
  def merge_response!(other); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#119
  sig { params(node: ::SyntaxTree::CallNode).void }
  def on_call(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#61
  sig { params(node: ::SyntaxTree::ClassDeclaration).void }
  def on_class(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#99
  sig { params(node: ::SyntaxTree::Command).void }
  def on_command(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#82
  sig { params(node: ::SyntaxTree::DefNode).void }
  def on_def(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#138
  sig { params(node: ::SyntaxTree::VCall).void }
  def on_vcall(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#34
  sig { override.returns(ResponseType) }
  def response; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#228
  sig { params(node: ::SyntaxTree::Command, remote: ::String).void }
  def add_open_gem_remote_code_lens(node, remote); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#156
  sig { params(node: ::SyntaxTree::Node, name: ::String, command: ::String, kind: ::Symbol).void }
  def add_test_code_lens(node, name:, command:, kind:); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#206
  sig { params(class_name: ::String, method_name: T.nilable(::String)).returns(::String) }
  def generate_test_command(class_name:, method_name: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#195
  sig { params(node: ::SyntaxTree::Command).returns(T.nilable(::String)) }
  def resolve_gem_remote(node); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#31
RubyLsp::Requests::CodeLens::ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/code_lens.rb#30
RubyLsp::Requests::CodeLens::BASE_COMMAND = T.let(T.unsafe(nil), String)

# ![Diagnostics demo](../../diagnostics.gif)
#
# The
# [diagnostics](https://microsoft.github.io/language-server-protocol/specification#textDocument_publishDiagnostics)
# request informs the editor of RuboCop offenses for a given file.
#
# # Example
#
# ```ruby
# def say_hello
# puts "Hello" # --> diagnostics: incorrect indentation
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/diagnostics.rb#21
class RubyLsp::Requests::Diagnostics < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/diagnostics.rb#25
  sig { params(document: ::RubyLsp::Document).void }
  def initialize(document); end

  # source://ruby-lsp/lib/ruby_lsp/requests/diagnostics.rb#32
  sig { override.returns(T.nilable(T.all(::Object, T::Array[::RubyLsp::Requests::Support::RuboCopDiagnostic]))) }
  def run; end
end

# ![Document highlight demo](../../document_highlight.gif)
#
# The [document highlight](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight)
# informs the editor all relevant elements of the currently pointed item for highlighting. For example, when
# the cursor is on the `F` of the constant `FOO`, the editor should identify other occurrences of `FOO`
# and highlight them.
#
# For writable elements like constants or variables, their read/write occurrences should be highlighted differently.
# This is achieved by sending different "kind" attributes to the editor (2 for read and 3 for write).
#
# # Example
#
# ```ruby
# FOO = 1 # should be highlighted as "write"
#
# def foo
#   FOO # should be highlighted as "read"
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#25
class RubyLsp::Requests::DocumentHighlight < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#29
  sig { params(document: ::RubyLsp::Document, position: {line: ::Integer, character: ::Integer}).void }
  def initialize(document, position); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#39
  sig { override.returns(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::DocumentHighlight])) }
  def run; end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#46
  sig { override.params(node: T.nilable(::SyntaxTree::Node)).void }
  def visit(node); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#89
  sig { params(match: ::RubyLsp::Requests::Support::HighlightTarget::HighlightMatch).void }
  def add_highlight(match); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#73
  sig do
    params(
      position: {line: ::Integer, character: ::Integer}
    ).returns(T.nilable(::RubyLsp::Requests::Support::HighlightTarget))
  end
  def find(position); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/document_highlight.rb#57
RubyLsp::Requests::DocumentHighlight::DIRECT_HIGHLIGHTS = T.let(T.unsafe(nil), Array)

# ![Document link demo](../../document_link.gif)
#
# The [document link](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentLink)
# makes `# source://PATH_TO_FILE#line` comments in a Ruby/RBI file clickable if the file exists.
# When the user clicks the link, it'll open that location.
#
# # Example
#
# ```ruby
# # source://syntax_tree/3.2.1/lib/syntax_tree.rb#51 <- it will be clickable and will take the user to that location
# def format(source, maxwidth = T.unsafe(nil))
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#21
class RubyLsp::Requests::DocumentLink < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::DocumentLink] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#79
  sig { params(uri: ::String, emitter: ::RubyLsp::EventEmitter, message_queue: ::Thread::Queue).void }
  def initialize(uri, emitter, message_queue); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#92
  sig { params(node: ::SyntaxTree::Comment).void }
  def on_comment(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#76
  sig { override.returns(ResponseType) }
  def response; end

  private

  # Try to figure out the gem version for a source:// link. The order of precedence is:
  # 1. The version in the URI
  # 2. The version in the RBI file name
  # 3. The version from the gemspec
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#115
  sig { params(uri: ::URI::Source).returns(T.nilable(::String)) }
  def resolve_version(uri); end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#38
    sig { returns(T::Hash[::String, T::Hash[::String, T::Hash[::String, ::String]]]) }
    def gem_paths; end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/document_link.rb#27
RubyLsp::Requests::DocumentLink::GEM_TO_VERSION_MAP = T.let(T.unsafe(nil), Hash)

# ![Document symbol demo](../../document_symbol.gif)
#
# The [document
# symbol](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentSymbol) request
# informs the editor of all the important symbols, such as classes, variables, and methods, defined in a file. With
# this information, the editor can populate breadcrumbs, file outline and allow for fuzzy symbol searches.
#
# In VS Code, fuzzy symbol search can be accessed by opening the command palette and inserting an `@` symbol.
#
# # Example
#
# ```ruby
# class Person # --> document symbol: class
#   attr_reader :age # --> document symbol: field
#
#   def initialize
#     @age = 0 # --> document symbol: variable
#   end
#
#   def age # --> document symbol: method
#   end
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#29
class RubyLsp::Requests::DocumentSymbol < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::DocumentSymbol] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#85
  sig { params(emitter: ::RubyLsp::EventEmitter, message_queue: ::Thread::Queue).void }
  def initialize(emitter, message_queue); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#121
  sig { params(node: ::SyntaxTree::ClassDeclaration).void }
  def after_class(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#174
  sig { params(node: ::SyntaxTree::DefNode).void }
  def after_def(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#189
  sig { params(node: ::SyntaxTree::ModuleDeclaration).void }
  def after_module(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#111
  sig { params(node: ::SyntaxTree::ClassDeclaration).void }
  def on_class(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#126
  sig { params(node: ::SyntaxTree::Command).void }
  def on_command(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#142
  sig { params(node: ::SyntaxTree::ConstPathField).void }
  def on_const_path_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#152
  sig { params(node: ::SyntaxTree::DefNode).void }
  def on_def(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#179
  sig { params(node: ::SyntaxTree::ModuleDeclaration).void }
  def on_module(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#194
  sig { params(node: ::SyntaxTree::TopConstField).void }
  def on_top_const_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#204
  sig { params(node: ::SyntaxTree::VarField).void }
  def on_var_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#82
  sig { override.returns(T::Array[::LanguageServer::Protocol::Interface::DocumentSymbol]) }
  def response; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#233
  sig do
    params(
      name: ::String,
      kind: ::Symbol,
      range_node: ::SyntaxTree::Node,
      selection_range_node: ::SyntaxTree::Node
    ).returns(::LanguageServer::Protocol::Interface::DocumentSymbol)
  end
  def create_document_symbol(name:, kind:, range_node:, selection_range_node:); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#67
RubyLsp::Requests::DocumentSymbol::ATTR_ACCESSORS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#35
RubyLsp::Requests::DocumentSymbol::SYMBOL_KIND = T.let(T.unsafe(nil), Hash)

# source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#69
class RubyLsp::Requests::DocumentSymbol::SymbolHierarchyRoot
  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#76
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/document_symbol.rb#73
  sig { returns(T::Array[::LanguageServer::Protocol::Interface::DocumentSymbol]) }
  def children; end
end

# ![Folding ranges demo](../../folding_ranges.gif)
#
# The [folding ranges](https://microsoft.github.io/language-server-protocol/specification#textDocument_foldingRange)
# request informs the editor of the ranges where and how code can be folded.
#
# # Example
#
# ```ruby
# def say_hello # <-- folding range start
#   puts "Hello"
# end # <-- folding range end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#18
class RubyLsp::Requests::FoldingRanges < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#64
  sig { params(document: ::RubyLsp::Document).void }
  def initialize(document); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#72
  sig { override.returns(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::FoldingRange])) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#223
  sig { params(node: T.any(::SyntaxTree::CallNode, ::SyntaxTree::CommandCall)).void }
  def add_call_range(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#257
  sig { params(node: ::SyntaxTree::DefNode).void }
  def add_def_range(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#296
  sig { params(start_line: ::Integer, end_line: ::Integer).void }
  def add_lines_range(start_line, end_line); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#281
  sig { params(node: ::SyntaxTree::Node, statements: ::SyntaxTree::Statements).void }
  def add_statements_range(node, statements); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#288
  sig { params(node: ::SyntaxTree::StringConcat).void }
  def add_string_concat(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#215
  sig { void }
  def emit_partial_range; end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#181
  sig { params(node: T.nilable(::SyntaxTree::Node)).returns(T::Boolean) }
  def handle_partial_range(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#203
  sig { params(node: T.nilable(::SyntaxTree::Node)).returns(T.nilable(::String)) }
  def partial_range_kind(node); end

  # This is to prevent duplicate ranges
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#120
  sig { params(node: T.any(::SyntaxTree::Command, ::SyntaxTree::CommandCall)).returns(T::Boolean) }
  def same_lines_for_command_and_block?(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#84
  sig { override.params(node: T.nilable(::SyntaxTree::Node)).void }
  def visit(node); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#42
RubyLsp::Requests::FoldingRanges::NODES_WITH_STATEMENTS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#129
class RubyLsp::Requests::FoldingRanges::PartialRange
  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#148
  sig { params(start_line: ::Integer, end_line: ::Integer, kind: ::String).void }
  def initialize(start_line, end_line, kind); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#136
  sig { returns(::Integer) }
  def end_line; end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#155
  sig { params(node: ::SyntaxTree::Node).returns(::RubyLsp::Requests::FoldingRanges::PartialRange) }
  def extend_to(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#133
  sig { returns(::String) }
  def kind; end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#175
  sig { returns(T::Boolean) }
  def multiline?; end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#161
  sig { params(node: ::SyntaxTree::Node).returns(T::Boolean) }
  def new_section?(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#166
  sig { returns(::LanguageServer::Protocol::Interface::FoldingRange) }
  def to_range; end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#142
    sig { params(node: ::SyntaxTree::Node, kind: ::String).returns(::RubyLsp::Requests::FoldingRanges::PartialRange) }
    def from(node, kind); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#21
RubyLsp::Requests::FoldingRanges::SIMPLE_FOLDABLES = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/folding_ranges.rb#53
RubyLsp::Requests::FoldingRanges::StatementNode = T.type_alias { T.any(::SyntaxTree::Elsif, ::SyntaxTree::IfNode, ::SyntaxTree::In, ::SyntaxTree::Rescue, ::SyntaxTree::When) }

# ![Formatting symbol demo](../../formatting.gif)
#
# The [formatting](https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting)
# request uses RuboCop to fix auto-correctable offenses in the document. This requires enabling format on save and
# registering the ruby-lsp as the Ruby formatter.
#
# The `rubyLsp.formatter` setting specifies which formatter to use.
# If set to `auto` then it behaves as follows:
# * It will use RuboCop if it is part of the bundle.
# * If RuboCop is not available, and `syntax_tree` is a direct dependency, it will use that.
# * Otherwise, no formatting will be applied.
#
# # Example
#
# ```ruby
# def say_hello
# puts "Hello" # --> formatting: fixes the indentation on save
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#28
class RubyLsp::Requests::Formatting < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#58
  sig { params(document: ::RubyLsp::Document, formatter: ::String).void }
  def initialize(document, formatter: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#66
  sig { override.returns(T.nilable(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::TextEdit]))) }
  def run; end

  private

  # @raise [InvalidFormatter]
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#94
  sig { returns(T.nilable(::String)) }
  def formatted_file; end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#43
    sig { returns(T::Hash[::String, ::RubyLsp::Requests::Support::FormatterRunner]) }
    def formatters; end

    # source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#46
    sig { params(identifier: ::String, instance: ::RubyLsp::Requests::Support::FormatterRunner).void }
    def register_formatter(identifier, instance); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#29
class RubyLsp::Requests::Formatting::Error < ::StandardError; end

# source://ruby-lsp/lib/ruby_lsp/requests/formatting.rb#30
class RubyLsp::Requests::Formatting::InvalidFormatter < ::StandardError; end

# ![Hover demo](../../rails_document_link_hover.gif)
#
# The [hover request](https://microsoft.github.io/language-server-protocol/specification#textDocument_hover)
# renders a clickable link to the code's official documentation.
# It currently only supports Rails' documentation: when hovering over Rails DSLs/constants under certain paths,
# like `before_save :callback` in `models/post.rb`, it generates a link to `before_save`'s API documentation.
#
# # Example
#
# ```ruby
# class Post < ApplicationRecord
#   before_save :do_something # when hovering on before_save, the link will be rendered
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#20
class RubyLsp::Requests::Hover < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T.nilable(::LanguageServer::Protocol::Interface::Hover) } }

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#39
  sig { params(emitter: ::RubyLsp::EventEmitter, message_queue: ::Thread::Queue).void }
  def initialize(emitter, message_queue); end

  # Merges responses from other hover listeners
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#48
  sig { params(other: RubyLsp::Listener[ResponseType]).returns(T.self_type) }
  def merge_response!(other); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#73
  sig { params(node: ::SyntaxTree::CallNode).void }
  def on_call(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#62
  sig { params(node: ::SyntaxTree::Command).void }
  def on_command(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#68
  sig { params(node: ::SyntaxTree::ConstPathRef).void }
  def on_const_path_ref(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#36
  sig { override.returns(ResponseType) }
  def response; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#83
  sig do
    params(
      name: ::String,
      node: ::SyntaxTree::Node
    ).returns(T.nilable(::LanguageServer::Protocol::Interface::Hover))
  end
  def generate_rails_document_link_hover(name, node); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/hover.rb#26
RubyLsp::Requests::Hover::ALLOWED_TARGETS = T.let(T.unsafe(nil), Array)

# ![Inlay hint demo](../../inlay_hint.gif)
#
# [Inlay hints](https://microsoft.github.io/language-server-protocol/specification#textDocument_inlayHint)
# are labels added directly in the code that explicitly show the user something that might
# otherwise just be implied.
#
# # Example
#
# ```ruby
# begin
#   puts "do something that might raise"
# rescue # Label "StandardError" goes here as a bare rescue implies rescuing StandardError
#   puts "handle some rescue"
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#21
class RubyLsp::Requests::InlayHints < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::InlayHint] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#33
  sig { params(range: T::Range[::Integer], emitter: ::RubyLsp::EventEmitter, message_queue: ::Thread::Queue).void }
  def initialize(range, emitter, message_queue); end

  # source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#43
  sig { params(node: ::SyntaxTree::Rescue).void }
  def on_rescue(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#30
  sig { override.returns(ResponseType) }
  def response; end
end

# source://ruby-lsp/lib/ruby_lsp/requests/inlay_hints.rb#27
RubyLsp::Requests::InlayHints::RESCUE_STRING_LENGTH = T.let(T.unsafe(nil), Integer)

# ![On type formatting demo](../../on_type_formatting.gif)
#
# The [on type formatting](https://microsoft.github.io/language-server-protocol/specification#textDocument_onTypeFormatting)
# request formats code as the user is typing. For example, automatically adding `end` to class definitions.
#
# # Example
#
# ```ruby
# class Foo # <-- upon adding a line break, on type formatting is triggered
#   # <-- cursor ends up here
# end # <-- end is automatically added
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#18
class RubyLsp::Requests::OnTypeFormatting < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#30
  sig do
    params(
      document: ::RubyLsp::Document,
      position: {line: ::Integer, character: ::Integer},
      trigger_character: ::String
    ).void
  end
  def initialize(document, position, trigger_character); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#46
  sig { override.returns(T.all(::Object, T::Array[::LanguageServer::Protocol::Interface::TextEdit])) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#124
  sig { params(text: ::String, position: {line: ::Integer, character: ::Integer}).void }
  def add_edit_with_text(text, position = T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#156
  sig { params(line: ::String).returns(::Integer) }
  def find_indentation(line); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#118
  sig { params(spaces: ::String).void }
  def handle_comment_line(spaces); end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#74
  sig { void }
  def handle_curly_brace; end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#66
  sig { void }
  def handle_pipe; end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#82
  sig { void }
  def handle_statement_end; end

  # source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#137
  sig { params(line: ::Integer, character: ::Integer).void }
  def move_cursor_to(line, character); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/on_type_formatting.rb#21
RubyLsp::Requests::OnTypeFormatting::END_REGEXES = T.let(T.unsafe(nil), Array)

# ![Path completion demo](../../path_completion.gif)
#
# The [completion](https://microsoft.github.io/language-server-protocol/specification#textDocument_completion)
# request looks up Ruby files in the $LOAD_PATH to suggest path completion inside `require` statements.
#
# # Example
#
# ```ruby
# require "ruby_lsp/requests" # --> completion: suggests `base_request`, `code_actions`, ...
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/path_completion.rb#16
class RubyLsp::Requests::PathCompletion < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::LanguageServer::Protocol::Interface::CompletionItem] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/path_completion.rb#26
  sig { params(emitter: ::RubyLsp::EventEmitter, message_queue: ::Thread::Queue).void }
  def initialize(emitter, message_queue); end

  # source://ruby-lsp/lib/ruby_lsp/requests/path_completion.rb#35
  sig { params(node: ::SyntaxTree::TStringContent).void }
  def on_tstring_content(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/path_completion.rb#23
  sig { override.returns(ResponseType) }
  def response; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/path_completion.rb#53
  sig do
    params(
      label: ::String,
      node: ::SyntaxTree::TStringContent
    ).returns(::LanguageServer::Protocol::Interface::CompletionItem)
  end
  def build_completion(label, node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/path_completion.rb#44
  sig { returns(T::Array[::String]) }
  def collect_load_path_files; end
end

# ![Selection ranges demo](../../selection_ranges.gif)
#
# The [selection ranges](https://microsoft.github.io/language-server-protocol/specification#textDocument_selectionRange)
# request informs the editor of ranges that the user may want to select based on the location(s)
# of their cursor(s).
#
# Trigger this request with: Ctrl + Shift + -> or Ctrl + Shift + <-
#
# Note that if using VSCode Neovim, you will need to be in Insert mode for this to work correctly.
#
# # Example
#
# ```ruby
# def foo # --> The next selection range encompasses the entire method definition.
#   puts "Hello, world!" # --> Cursor is on this line
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#23
class RubyLsp::Requests::SelectionRanges < ::RubyLsp::Requests::BaseRequest
  # source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#66
  sig { params(document: ::RubyLsp::Document).void }
  def initialize(document); end

  # source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#74
  sig { override.returns(T.all(::Object, T::Array[::RubyLsp::Requests::Support::SelectionRange])) }
  def run; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#101
  sig do
    params(
      location: ::SyntaxTree::Location,
      parent: T.nilable(::RubyLsp::Requests::Support::SelectionRange)
    ).returns(::RubyLsp::Requests::Support::SelectionRange)
  end
  def create_selection_range(location, parent = T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#82
  sig { override.params(node: T.nilable(::SyntaxTree::Node)).void }
  def visit(node); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/selection_ranges.rb#26
RubyLsp::Requests::SelectionRanges::NODES_THAT_CAN_BE_PARENTS = T.let(T.unsafe(nil), Array)

# ![Semantic highlighting demo](../../semantic_highlighting.gif)
#
# The [semantic
# highlighting](https://microsoft.github.io/language-server-protocol/specification#textDocument_semanticTokens)
# request informs the editor of the correct token types to provide consistent and accurate highlighting for themes.
#
# # Example
#
# ```ruby
# def foo
#   var = 1 # --> semantic highlighting: local variable
#   some_invocation # --> semantic highlighting: method invocation
#   var # --> semantic highlighting: local variable
# end
# ```
#
# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#21
class RubyLsp::Requests::SemanticHighlighting < ::RubyLsp::Listener
  extend T::Generic

  ResponseType = type_member { { fixed: T::Array[::RubyLsp::Requests::SemanticHighlighting::SemanticToken] } }

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#117
  sig do
    params(
      emitter: ::RubyLsp::EventEmitter,
      message_queue: ::Thread::Queue,
      range: T.nilable(T::Range[::Integer])
    ).void
  end
  def initialize(emitter, message_queue, range: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#327
  sig { params(location: ::SyntaxTree::Location, type: ::Symbol, modifiers: T::Array[::Symbol]).void }
  def add_token(location, type, modifiers = T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#286
  sig { params(node: ::SyntaxTree::Binary).void }
  def after_binary(node); end

  # All block locals are variables. E.g.: [].each do |x; block_local|
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#254
  sig { params(node: ::SyntaxTree::BlockVar).void }
  def on_block_var(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#146
  sig { params(node: ::SyntaxTree::CallNode).void }
  def on_call(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#310
  sig { params(node: ::SyntaxTree::ClassDeclaration).void }
  def on_class(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#157
  sig { params(node: ::SyntaxTree::Command).void }
  def on_command(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#164
  sig { params(node: ::SyntaxTree::CommandCall).void }
  def on_command_call(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#172
  sig { params(node: ::SyntaxTree::Const).void }
  def on_const(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#183
  sig { params(node: ::SyntaxTree::DefNode).void }
  def on_def(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#220
  sig { params(node: ::SyntaxTree::Field).void }
  def on_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#190
  sig { params(node: ::SyntaxTree::Kw).void }
  def on_kw(node); end

  # All lambda locals are variables. E.g.: ->(x; lambda_local) {}
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#260
  sig { params(node: ::SyntaxTree::LambdaVar).void }
  def on_lambda_var(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#320
  sig { params(node: ::SyntaxTree::ModuleDeclaration).void }
  def on_module(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#200
  sig { params(node: ::SyntaxTree::Params).void }
  def on_params(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#227
  sig { params(node: ::SyntaxTree::VarField).void }
  def on_var_field(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#240
  sig { params(node: ::SyntaxTree::VarRef).void }
  def on_var_ref(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#265
  sig { params(node: ::SyntaxTree::VCall).void }
  def on_vcall(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#108
  sig { override.returns(ResponseType) }
  def response; end

  private

  # Exclude the ":" symbol at the end of a location
  # We use it on keyword parameters to be consistent
  # with the rest of the parameters
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#346
  sig { params(location: T.untyped).returns(::SyntaxTree::Location) }
  def location_without_colon(location); end

  # Textmate provides highlighting for a subset
  # of these special Ruby-specific methods.
  # We want to utilize that highlighting, so we
  # avoid making a semantic token for it.
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#362
  sig { params(method_name: ::String).returns(T::Boolean) }
  def special_method?(method_name); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#367
  sig { params(value: ::SyntaxTree::Ident).returns(::Symbol) }
  def type_for_local(value); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#72
RubyLsp::Requests::SemanticHighlighting::SPECIAL_RUBY_METHODS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#83
class RubyLsp::Requests::SemanticHighlighting::SemanticToken
  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#99
  sig do
    params(
      location: ::SyntaxTree::Location,
      length: ::Integer,
      type: ::Integer,
      modifier: T::Array[::Integer]
    ).void
  end
  def initialize(location:, length:, type:, modifier:); end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#90
  sig { returns(::Integer) }
  def length; end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#87
  sig { returns(::SyntaxTree::Location) }
  def location; end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#96
  sig { returns(T::Array[::Integer]) }
  def modifier; end

  # source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#93
  sig { returns(::Integer) }
  def type; end
end

# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#56
RubyLsp::Requests::SemanticHighlighting::TOKEN_MODIFIERS = T.let(T.unsafe(nil), Hash)

# source://ruby-lsp/lib/ruby_lsp/requests/semantic_highlighting.rb#27
RubyLsp::Requests::SemanticHighlighting::TOKEN_TYPES = T.let(T.unsafe(nil), Hash)

# source://ruby-lsp/lib/ruby_lsp/requests.rb#42
module RubyLsp::Requests::Support; end

# source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#7
class RubyLsp::Requests::Support::Annotation
  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#15
  sig { params(arity: T.any(::Integer, T::Range[::Integer]), receiver: T::Boolean).void }
  def initialize(arity:, receiver: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#21
  sig { returns(T.any(::Integer, T::Range[::Integer])) }
  def arity; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#24
  sig { returns(T::Boolean) }
  def receiver; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#27
  sig { params(arity: T.any(::Integer, T::Range[::Integer])).returns(T::Boolean) }
  def supports_arity?(arity); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/annotation.rb#38
  sig { params(receiver: T.nilable(::String)).returns(T::Boolean) }
  def supports_receiver?(receiver); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#7
module RubyLsp::Requests::Support::Common
  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#64
  sig do
    params(
      node: ::SyntaxTree::Node,
      title: ::String,
      command_name: ::String,
      arguments: T.nilable(T::Array[T.untyped]),
      data: T.nilable(T::Hash[T.untyped, T.untyped])
    ).returns(::LanguageServer::Protocol::Interface::CodeLens)
  end
  def create_code_lens(node, title:, command_name:, arguments:, data:); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#28
  sig do
    params(
      node: T.any(::SyntaxTree::ConstPathRef, ::SyntaxTree::ConstRef, ::SyntaxTree::TopConstRef)
    ).returns(::String)
  end
  def full_constant_name(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#13
  sig { params(node: ::SyntaxTree::Node).returns(::LanguageServer::Protocol::Interface::Range) }
  def range_from_syntax_tree_node(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/common.rb#47
  sig { params(node: T.nilable(::SyntaxTree::Node), range: T.nilable(T::Range[::Integer])).returns(T::Boolean) }
  def visible?(node, range); end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://ruby-lsp/lib/ruby_lsp/requests/support/formatter_runner.rb#7
module RubyLsp::Requests::Support::FormatterRunner
  interface!

  # @abstract
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/support/formatter_runner.rb#14
  sig { abstract.params(uri: ::String, document: ::RubyLsp::Document).returns(T.nilable(::String)) }
  def run(uri, document); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#7
class RubyLsp::Requests::Support::HighlightTarget
  # source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#30
  sig { params(node: ::SyntaxTree::Node).void }
  def initialize(node); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#36
  sig do
    params(
      other: ::SyntaxTree::Node
    ).returns(T.nilable(::RubyLsp::Requests::Support::HighlightTarget::HighlightMatch))
  end
  def highlight_type(other); end

  private

  # Match the target type (where the cursor is positioned) with the `other` type (the node we're currently
  # visiting)
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#45
  sig do
    params(
      other: ::SyntaxTree::Node
    ).returns(T.nilable(::RubyLsp::Requests::Support::HighlightTarget::HighlightMatch))
  end
  def matched_highlight(other); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#77
  sig { params(node: ::SyntaxTree::Node).returns(T.nilable(::String)) }
  def value(node); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#13
class RubyLsp::Requests::Support::HighlightTarget::HighlightMatch
  # source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#23
  sig { params(type: ::Integer, node: ::SyntaxTree::Node).void }
  def initialize(type:, node:); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#20
  sig { returns(::SyntaxTree::Node) }
  def node; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#17
  sig { returns(::Integer) }
  def type; end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#10
RubyLsp::Requests::Support::HighlightTarget::READ = T.let(T.unsafe(nil), Integer)

# source://ruby-lsp/lib/ruby_lsp/requests/support/highlight_target.rb#11
RubyLsp::Requests::Support::HighlightTarget::WRITE = T.let(T.unsafe(nil), Integer)

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#19
class RubyLsp::Requests::Support::InternalRuboCopError < ::StandardError
  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#29
  sig { params(rubocop_error: ::RuboCop::ErrorWithAnalyzedFileLocation).void }
  def initialize(rubocop_error); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#22
RubyLsp::Requests::Support::InternalRuboCopError::MESSAGE = T.let(T.unsafe(nil), String)

# source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#7
class RubyLsp::Requests::Support::PrefixTree
  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#11
  sig { params(items: T::Array[::String]).void }
  def initialize(items); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#20
  sig { params(prefix: ::String).returns(T::Array[::String]) }
  def search(prefix); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#36
  sig { params(item: ::String).void }
  def insert(item); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#46
class RubyLsp::Requests::Support::PrefixTree::Node
  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#59
  sig { params(value: ::String).void }
  def initialize(value); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#50
  sig { returns(T::Hash[::String, ::RubyLsp::Requests::Support::PrefixTree::Node]) }
  def children; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#66
  sig { returns(T::Array[::String]) }
  def collect; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#56
  sig { returns(T::Boolean) }
  def leaf; end

  # @return [Boolean]
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#56
  def leaf=(_arg0); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/prefix_tree.rb#53
  sig { returns(::String) }
  def value; end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rails_document_client.rb#9
class RubyLsp::Requests::Support::RailsDocumentClient
  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/support/rails_document_client.rb#37
    sig { params(name: ::String).returns(T::Array[::String]) }
    def generate_rails_document_urls(name); end

    private

    # source://ruby-lsp/lib/ruby_lsp/requests/support/rails_document_client.rb#66
    sig { returns(T.nilable(T::Hash[::String, T::Array[T::Hash[::Symbol, ::String]]])) }
    def build_search_index; end

    # source://ruby-lsp/lib/ruby_lsp/requests/support/rails_document_client.rb#90
    sig { params(js: ::String).returns(T::Hash[::String, T::Array[T::Hash[::Symbol, ::String]]]) }
    def process_search_index(js); end

    # source://ruby-lsp/lib/ruby_lsp/requests/support/rails_document_client.rb#58
    sig { returns(T.nilable(T::Hash[::String, T::Array[T::Hash[::Symbol, ::String]]])) }
    def search_index; end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rails_document_client.rb#10
RubyLsp::Requests::Support::RailsDocumentClient::RAILS_DOC_HOST = T.let(T.unsafe(nil), String)

# source://ruby-lsp/lib/ruby_lsp/requests/support/rails_document_client.rb#25
RubyLsp::Requests::Support::RailsDocumentClient::RAILTIES_VERSION = T.let(T.unsafe(nil), String)

# source://ruby-lsp/lib/ruby_lsp/requests/support/rails_document_client.rb#11
RubyLsp::Requests::Support::RailsDocumentClient::SUPPORTED_RAILS_DOC_NAMESPACES = T.let(T.unsafe(nil), Regexp)

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#7
class RubyLsp::Requests::Support::RuboCopDiagnostic
  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#23
  sig { params(offense: ::RuboCop::Cop::Offense, uri: ::String).void }
  def initialize(offense, uri); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#29
  sig { returns(::LanguageServer::Protocol::Interface::CodeAction) }
  def to_lsp_code_action; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#49
  sig { returns(::LanguageServer::Protocol::Interface::Diagnostic) }
  def to_lsp_diagnostic; end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#83
  sig { returns(T::Array[::LanguageServer::Protocol::Interface::TextEdit]) }
  def offense_replacements; end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostic.rb#10
RubyLsp::Requests::Support::RuboCopDiagnostic::RUBOCOP_TO_LSP_SEVERITY = T.let(T.unsafe(nil), Hash)

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostics_runner.rb#13
class RubyLsp::Requests::Support::RuboCopDiagnosticsRunner
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostics_runner.rb#18
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_diagnostics_runner.rb#23
  sig do
    params(
      uri: ::String,
      document: ::RubyLsp::Document
    ).returns(T::Array[::RubyLsp::Requests::Support::RuboCopDiagnostic])
  end
  def run(uri, document); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_formatting_runner.rb#13
class RubyLsp::Requests::Support::RuboCopFormattingRunner
  include ::Singleton
  include ::RubyLsp::Requests::Support::FormatterRunner
  extend ::Singleton::SingletonClassMethods

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_formatting_runner.rb#19
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_formatting_runner.rb#25
  sig { override.params(uri: ::String, document: ::RubyLsp::Document).returns(::String) }
  def run(uri, document); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#36
class RubyLsp::Requests::Support::RuboCopRunner < ::RuboCop::Runner
  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#63
  sig { params(args: ::String).void }
  def initialize(*args); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#95
  sig { returns(::String) }
  def formatted_source; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#42
  sig { returns(T::Array[::RuboCop::Cop::Offense]) }
  def offenses; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#77
  sig { params(path: ::String, contents: ::String).void }
  def run(path, contents); end

  private

  # source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#102
  sig { params(_file: ::String, offenses: T::Array[::RuboCop::Cop::Offense]).void }
  def file_finished(_file, offenses); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#39
class RubyLsp::Requests::Support::RuboCopRunner::ConfigurationError < ::StandardError; end

# source://ruby-lsp/lib/ruby_lsp/requests/support/rubocop_runner.rb#44
RubyLsp::Requests::Support::RuboCopRunner::DEFAULT_ARGS = T.let(T.unsafe(nil), Array)

# source://ruby-lsp/lib/ruby_lsp/requests/support/selection_range.rb#7
class RubyLsp::Requests::Support::SelectionRange < ::LanguageServer::Protocol::Interface::SelectionRange
  # source://ruby-lsp/lib/ruby_lsp/requests/support/selection_range.rb#11
  sig { params(position: {line: ::Integer, character: ::Integer}).returns(T::Boolean) }
  def cover?(position); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#7
class RubyLsp::Requests::Support::SemanticTokenEncoder
  # source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#11
  sig { void }
  def initialize; end

  # For more information on how each number is calculated, read:
  # https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_semanticTokens
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#43
  sig { params(token: ::RubyLsp::Requests::SemanticHighlighting::SemanticToken).returns(T::Array[::Integer]) }
  def compute_delta(token); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#21
  sig do
    params(
      tokens: T::Array[::RubyLsp::Requests::SemanticHighlighting::SemanticToken]
    ).returns(::LanguageServer::Protocol::Interface::SemanticTokens)
  end
  def encode(tokens); end

  # Encode an array of modifiers to positions onto a bit flag
  # For example, [:default_library] will be encoded as
  # 0b1000000000, as :default_library is the 10th bit according
  # to the token modifiers index map.
  #
  # source://ruby-lsp/lib/ruby_lsp/requests/support/semantic_token_encoder.rb#62
  sig { params(modifiers: T::Array[::Integer]).returns(::Integer) }
  def encode_modifiers(modifiers); end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/sorbet.rb#7
class RubyLsp::Requests::Support::Sorbet
  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/support/sorbet.rb#48
    sig { params(node: T.any(::SyntaxTree::CallNode, ::SyntaxTree::VCall)).returns(T::Boolean) }
    def annotation?(node); end

    private

    # source://ruby-lsp/lib/ruby_lsp/requests/support/sorbet.rb#61
    sig do
      params(
        node: T.any(::SyntaxTree::CallNode, ::SyntaxTree::VCall)
      ).returns(T.nilable(::RubyLsp::Requests::Support::Annotation))
    end
    def annotation(node); end

    # source://ruby-lsp/lib/ruby_lsp/requests/support/sorbet.rb#90
    sig { params(node: T.nilable(::SyntaxTree::Node)).returns(T.nilable(::String)) }
    def node_name(node); end

    # source://ruby-lsp/lib/ruby_lsp/requests/support/sorbet.rb#76
    sig { params(receiver: T.any(::SyntaxTree::CallNode, ::SyntaxTree::VCall)).returns(T.nilable(::String)) }
    def receiver_name(receiver); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/syntax_tree_formatting_runner.rb#11
class RubyLsp::Requests::Support::SyntaxTreeFormattingRunner
  include ::Singleton
  include ::RubyLsp::Requests::Support::FormatterRunner
  extend ::Singleton::SingletonClassMethods

  # source://ruby-lsp/lib/ruby_lsp/requests/support/syntax_tree_formatting_runner.rb#17
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/syntax_tree_formatting_runner.rb#30
  sig { override.params(uri: ::String, document: ::RubyLsp::Document).returns(T.nilable(::String)) }
  def run(uri, document); end
end

# The final result of running a request before its IO is finalized
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#35
class RubyLsp::Result
  # source://ruby-lsp/lib/ruby_lsp/utils.rb#54
  sig { params(response: T.untyped, error: T.nilable(::Exception), request_time: T.nilable(::Float)).void }
  def initialize(response:, error: T.unsafe(nil), request_time: T.unsafe(nil)); end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#42
  sig { returns(T.nilable(::Exception)) }
  def error; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#45
  sig { returns(T.nilable(::Float)) }
  def request_time; end

  # source://ruby-lsp/lib/ruby_lsp/utils.rb#39
  sig { returns(T.untyped) }
  def response; end
end

# source://ruby-lsp/lib/ruby_lsp/server.rb#11
class RubyLsp::Server
  # source://ruby-lsp/lib/ruby_lsp/server.rb#15
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/server.rb#60
  sig { void }
  def start; end

  private

  # Finalize a Queue::Result. All IO operations should happen here to avoid any issues with cancelling requests
  #
  # source://ruby-lsp/lib/ruby_lsp/server.rb#142
  sig { params(result: ::RubyLsp::Result, request: T::Hash[::Symbol, T.untyped]).void }
  def finalize_request(result, request); end

  # source://ruby-lsp/lib/ruby_lsp/server.rb#117
  sig { returns(::Thread) }
  def new_worker; end

  # source://ruby-lsp/lib/ruby_lsp/server.rb#174
  sig do
    params(
      request: T::Hash[::Symbol, T.untyped],
      request_time: ::Float,
      error: T.nilable(::Exception)
    ).returns(T::Hash[::Symbol, T.any(::Float, ::String)])
  end
  def telemetry_params(request, request_time, error); end
end

# source://ruby-lsp/lib/ruby_lsp/store.rb#9
class RubyLsp::Store
  # source://ruby-lsp/lib/ruby_lsp/store.rb#19
  sig { void }
  def initialize; end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#68
  sig do
    type_parameters(:T)
      .params(
        uri: ::String,
        request_name: ::String,
        block: T.proc.params(document: ::RubyLsp::Document).returns(T.type_parameter(:T))
      ).returns(T.type_parameter(:T))
  end
  def cache_fetch(uri, request_name, &block); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#46
  sig { void }
  def clear; end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#56
  sig { params(uri: ::String).void }
  def delete(uri); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#51
  sig { returns(T::Boolean) }
  def empty?; end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#13
  sig { returns(::String) }
  def encoding; end

  # @return [String]
  #
  # source://ruby-lsp/lib/ruby_lsp/store.rb#13
  def encoding=(_arg0); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#16
  sig { returns(::String) }
  def formatter; end

  # @return [String]
  #
  # source://ruby-lsp/lib/ruby_lsp/store.rb#16
  def formatter=(_arg0); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#26
  sig { params(uri: ::String).returns(::RubyLsp::Document) }
  def get(uri); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#41
  sig do
    params(
      uri: ::String,
      edits: T::Array[{range: {start: {line: ::Integer, character: ::Integer}, end: {line: ::Integer, character: ::Integer}}, text: ::String}],
      version: ::Integer
    ).void
  end
  def push_edits(uri:, edits:, version:); end

  # source://ruby-lsp/lib/ruby_lsp/store.rb#35
  sig { params(uri: ::String, source: ::String, version: ::Integer).void }
  def set(uri:, source:, version:); end
end

# source://ruby-lsp/lib/ruby_lsp/server.rb#8
RubyLsp::Transport = LanguageServer::Protocol::Transport

# source://ruby-lsp/lib/ruby-lsp.rb#5
RubyLsp::VERSION = T.let(T.unsafe(nil), String)

# Used to indicate that a request shouldn't return a response
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#6
RubyLsp::VOID = T.let(T.unsafe(nil), Object)

# This freeze is not redundant since the interpolated string is mutable
#
# source://ruby-lsp/lib/ruby_lsp/utils.rb#9
RubyLsp::WORKSPACE_URI = T.let(T.unsafe(nil), URI::File)

# source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#6
module URI
  include ::URI::RFC2396_REGEXP
end

# Must be kept in sync with the one in Tapioca
#
# source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#8
class URI::Source < ::URI::File
  # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#62
  sig { params(v: T.nilable(::String)).returns(T::Boolean) }
  def check_host(v); end

  def gem_name; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#26
  sig { returns(T.nilable(::String)) }
  def gem_version; end

  def line_number; end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#52
  sig { params(v: T.nilable(::String)).void }
  def set_path(v); end

  # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#74
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#39
    sig do
      params(
        gem_name: ::String,
        gem_version: T.nilable(::String),
        path: ::String,
        line_number: T.nilable(::String)
      ).returns(::URI::Source)
    end
    def build(gem_name:, gem_version:, path:, line_number:); end
  end
end

# source://ruby-lsp/lib/ruby_lsp/requests/support/source_uri.rb#11
URI::Source::COMPONENT = T.let(T.unsafe(nil), Array)

class URI::WSS < ::URI::WS; end
